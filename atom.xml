<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洋洋&#39;s Blog</title>
  
  <subtitle>Saty Hungry，Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-27T09:55:07.692Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YangYang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flask总结</title>
    <link href="http://yoursite.com/2019/11/21/Flask%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/21/Flask总结/</id>
    <published>2019-11-21T09:25:25.000Z</published>
    <updated>2019-11-27T09:55:07.692Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="小-demo"><a href="#小-demo" class="headerlink" title="小 demo"></a>小 demo</h2><pre><code>from flask import Flask  // 导入flaskapp = Flask(__name__)  // 创建类实例@app.route(&quot;/&quot;)  // 使用 route() 装饰器来告诉 Flask 触发函数的 URL def hello():    return &quot;Hello World!&quot;if __name__ == &quot;__main__&quot;:  // 确保服务器只会在使用 Python 解释器运行代码的 情况下运行，而不会在作为模块导入时运行    app.run()  //  run() 函数来运行本地服务器和我们的应用</code></pre><p>运行： python hello.py</p><h2 id="Werkzeug"><a href="#Werkzeug" class="headerlink" title="Werkzeug"></a>Werkzeug</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>不是一个web服务器，也不是一个web框架，而是一个工具包，官方的介绍说是一个 WSGI 工具包，它可以作为一个 Web 框架的底层库，因为它封装好了很多 Web 框架的东西，例如 Request，Response 等等。</p><p>什么又是WSGI呢？WSGI的全称是Web Server Gateway Interface，它是用来定义web服务器接口的一个规范。简单地讲，就是定义http服务器应该长什么样子，能处理哪些事情。</p><h3 id="包含哪些内容的实现"><a href="#包含哪些内容的实现" class="headerlink" title="包含哪些内容的实现"></a>包含哪些内容的实现</h3><ul><li>HTTP头的解析</li><li>易用使用的request和response对象</li><li>基于交互风格的JavaScript脚本语言的浏览器调试器</li><li>与 WSGI 1.0 规范100%兼容</li><li>支持Python 2.6, 2.7和3.3</li><li>Unicode支持</li><li>HTTP Session和签名Cookie支持</li><li>URI和IRI处理函数，包含对Unicode的支持</li><li>内置兼容一些非标准的WSGI服务器和浏览器</li><li>集成了URLs路由功能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Flask" scheme="http://yoursite.com/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>nginx总结</title>
    <link href="http://yoursite.com/2019/11/21/nginx%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/21/nginx总结/</id>
    <published>2019-11-21T09:25:25.000Z</published>
    <updated>2019-11-27T10:05:25.011Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5d81906c518825300a3ec7ca" target="_blank" rel="noopener">nginx 这一篇就够了</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。<br><img src="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191127095906nginx.png" alt="nginx"></p><h2 id="nginx-服务架构"><a href="#nginx-服务架构" class="headerlink" title="nginx 服务架构"></a>nginx 服务架构</h2><blockquote><p>nginx 服务器的开发完全遵循模块化设计思想</p></blockquote><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><ul><li>单一职责原则，一个模块只负责一个功能</li><li>将程序分解，自顶向下，逐步求精</li><li>高内聚，低耦合</li></ul><h3 id="nginx-的模块化结构"><a href="#nginx-的模块化结构" class="headerlink" title="nginx 的模块化结构"></a>nginx 的模块化结构</h3><ul><li>核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录；</li><li>标准 HTTP 模块：nginx 服务器的标准 HTTP 功能；</li><li>可选 HTTP 模块：处理特殊的 HTTP 请求</li><li>邮件服务模块：邮件服务</li><li>第三方模块：作为扩展，完成特殊功能</li></ul><h2 id="nginx-配置文件实例"><a href="#nginx-配置文件实例" class="headerlink" title="nginx 配置文件实例"></a>nginx 配置文件实例</h2><pre><code>#定义 nginx 运行的用户和用户组user www www;#nginx 进程数，建议设置为等于 CPU 总核心数。worker_processes 8;#nginx 默认没有开启利用多核 CPU, 通过增加 worker_cpu_affinity 配置参数来充分利用多核 CPU 以下是 8 核的配置参数worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个 nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值 ulimit -n）与 nginx 进程数相除，但是 nginx 分配请求并不均匀，所以建议与 ulimit -n 的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events{    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll 模型是 Linux 2.6 以上版本内核中的高性能网络 I/O 模型，如果跑在 FreeBSD 上面，就用 kqueue 模型。    #epoll 是多路复用 IO(I/O Multiplexing) 中的一种方式，但是仅用于 linux2.6 以上内核，可以大大提高 nginx 的性能    use epoll;    ############################################################################    #单个后台 worker process 进程的最大并发链接数    #事件模块指令，定义 nginx 每个进程最大连接数，默认 1024。最大客户连接数由 worker_processes 和 worker_connections 决定    #即 max_client=worker_processes*worker_connections, 在作为反向代理时：max_client=worker_processes*worker_connections / 4    worker_connections 65535;    ############################################################################}#设定 http 服务器http {    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的 hash 表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓    sendfile on; #开启高效文件传输模式，sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成 off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    ##连接客户端超时时间各种参数设置##    keepalive_timeout  120;          #单位是秒，客户端连接时时间，超时之后服务器端自动关闭该连接 如果 nginx 守护进程在这个等待的时间里，一直没有收到浏览发过来 http 请求，则关闭这个 http 连接    client_header_timeout 10;        #客户端请求头的超时时间    client_body_timeout 10;          #客户端请求主体超时时间    reset_timedout_connection on;    #告诉 nginx 关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间    send_timeout 10;                 #客户端响应超时时间，在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx 就会关闭连接    ################################    #FastCGI 相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    ###作为代理缓存服务器设置#######    ###先写到 temp 再移动到 cache    #proxy_cache_path /var/tmp/nginx/proxy_cache levels=1:2 keys_zone=cache_one:512m inactive=10m max_size=64m;    ###以上 proxy_temp 和 proxy_cache 需要在同一个分区中    ###levels=1:2 表示缓存级别，表示缓存目录的第一级目录是 1 个字符，第二级目录是 2 个字符 keys_zone=cache_one:128m 缓存空间起名为 cache_one 大小为 512m    ###max_size=64m 表示单个文件超过 128m 就不缓存了  inactive=10m 表示缓存的数据，10 分钟内没有被访问过就删除    #########end####################    #####对传输文件压缩###########    #gzip 模块设置    gzip on; #开启 gzip 压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认 1.1，前端如果是 squid2.5 请使用 1.0）    gzip_comp_level 2; #压缩等级，gzip 压缩比，1 为最小，处理最快；9 为压缩比最大，处理最慢，传输速度最快，也最消耗 CPU；    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含 text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个 warn。    gzip_vary on;    ##############################    #limit_zone crawler $binary_remote_addr 10m; #开启限制 IP 连接数的时候需要使用    upstream blog.ha97.com {        #upstream 的负载均衡，weight 是权重，可以根据机器配置定义权重。weigth 参数表示权值，权值越高被分配到的几率越大。        server 192.168.80.121:80 weight=3;        server 192.168.80.122:80 weight=2;        server 192.168.80.123:80 weight=3;    }    #虚拟主机的配置    server {        #监听端口        listen 80;        #############https##################        #listen 443 ssl;        #ssl_certificate /opt/https/xxxxxx.crt;        #ssl_certificate_key /opt/https/xxxxxx.key;        #ssl_protocols SSLv3 TLSv1;        #ssl_ciphers HIGH:!ADH:!EXPORT57:RC4+RSA:+MEDIUM;        #ssl_prefer_server_ciphers on;        #ssl_session_cache shared:SSL:2m;        #ssl_session_timeout 5m;        ####################################end        #域名可以有多个，用空格隔开        server_name www.ha97.com ha97.com;        index index.html index.htm index.php;        root /data/www/ha97;        location ~ .*.(php|php5)?$ {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ {            expires 10d;        }        #JS 和 CSS 缓存时间设置        location ~ .*.(js|css)?$ {            expires 1h;        }        #日志格式设定        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;        #定义本虚拟主机的访问日志        access_log /var/log/nginx/ha97access.log access;        #对 &quot;/&quot; 启用反向代理        location / {            proxy_pass http://127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的 Web 服务器可以通过 X-Forwarded-For 获取用户真实 IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置，可选。            proxy_set_header Host $host;            client_max_body_size 10m; #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，            ##代理设置 以下设置是 nginx 和后端服务器之间通讯的设置##            proxy_connect_timeout 90; #nginx 跟后端服务器连接超时时间（代理连接超时）            proxy_send_timeout 90; #后端服务器数据回传时间（代理发送超时）            proxy_read_timeout 90; #连接成功后，后端服务器响应时间（代理接收超时）            proxy_buffering on;    #该指令开启从后端被代理服务器的响应内容缓冲 此参数开启后 proxy_buffers 和 proxy_busy_buffers_size 参数才会起作用            proxy_buffer_size 4k;  #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k;   #proxy_buffers 缓冲区，网页平均在 32k 以下的设置            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）            proxy_max_temp_file_size 2048m; #默认 1024m, 该指令用于设置当网页内容大于 proxy_buffers 时，临时文件大小的最大值。如果文件大于这个值，它将从 upstream 服务器同步地传递请求，而不是缓冲到磁盘            proxy_temp_file_write_size 512k; 这是当被代理服务器的响应过大时 nginx 一次性写入临时文件的数据量。            proxy_temp_path  /var/tmp/nginx/proxy_temp;    ##定义缓冲存储目录，之前必须要先手动创建此目录            proxy_headers_hash_max_size 51200;            proxy_headers_hash_bucket_size 6400;            #######################################################        }        #设定查看 nginx 状态的地址        location /nginxStatus {            stub_status on;            access_log on;            auth_basic &quot;nginxStatus&quot;;            auth_basic_user_file conf/htpasswd;            #htpasswd 文件的内容可以用 apache 提供的 htpasswd 工具来产生。        }        #本地动静分离反向代理配置        #所有 jsp 的页面均交由 tomcat 或 resin 处理        location ~ .(jsp|jspx|do)?$ {            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http://127.0.0.1:8080;        }        #所有静态文件由 nginx 直接读取不经过 tomcat 或 resin        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$        { expires 15d; }        location ~ .*.(js|css)?$        { expires 1h; }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>消息队列&amp;CMQ</title>
    <link href="http://yoursite.com/2019/09/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&amp;CMQ/"/>
    <id>http://yoursite.com/2019/09/26/消息队列&amp;CMQ/</id>
    <published>2019-09-26T07:25:25.000Z</published>
    <updated>2019-11-27T08:54:53.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png" alt="hh"></p><a id="more"></a><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>QPS</strong>： Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p><strong>TPS</strong>： 是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p><strong>吞吐量</strong>： 一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。</p><p>是指在一次性能测试过程中网络上传输的数据量的总和。但一般指指系统在单位时间内处理请求的数量</p><p><strong>吞吐率</strong>: 特指Web服务器单位时间内处理的请求数。</p><p>系统吞吐量几个重要参数：</p><ul><li>QPS（TPS）：每秒钟request/事务 数量</li><li>并发数： 系统同时处理的request/事务数</li><li>响应时间：  一般取平均响应时间</li></ul><p>理解了上面三个要素的意义之后，就能推算出它们之间的关系：<br>QPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS*平均响应时间</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。</p><p>同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。</p><p>CMQ/CKafka/MQ for IoT本质上都属于分布式消息中间件，分布式消息系统的最大特点是可扩展性。核心理念是多个节点协同工作完成单个节点无法完成的任务，不允许出现单节点故障服务不可用（RTO）和数据丢失（RPO）情况。归根结底是解决CAP问题, CMQ作为金融级别服务要求数据高可靠强一致（CP）, CKafka以大数据领域为主要服务对象，更偏重于AP,同时允许用户通过配置在CAP之间进行权衡</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>服务解耦</strong>： 多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；</li><li><strong>异步处理</strong>： 多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间。如用户注册后，需要发送注册邮件和发送注册信息，传统的做法有两种：串行方式、并行方式</li><li><strong>削峰限流</strong>： 广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li><li><strong>广播订阅</strong>： 发送方不关心谁订阅这个消息，只管发出来，拓展方便；</li><li>流式数据过滤： 消费者通过类似SQL语句来筛选自己感兴趣的数据；</li><li>两阶段消息： 通过两阶段消息与本地数据库事务相结合达到简单分布式事务。</li></ul><h3 id="两种消息模型"><a href="#两种消息模型" class="headerlink" title="两种消息模型"></a>两种消息模型</h3><h4 id="P2P（Point-to-Point）"><a href="#P2P（Point-to-Point）" class="headerlink" title="P2P（Point to Point）"></a>P2P（Point to Point）</h4><p>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><p>P2P的特点：</p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><h4 id="Publish-Subscribe-Pub-Sub"><a href="#Publish-Subscribe-Pub-Sub" class="headerlink" title="Publish/Subscribe(Pub/Sub)"></a>Publish/Subscribe(Pub/Sub)</h4><p>包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p><p>Pub/Sub的特点:</p><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li><li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li><li>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</li></ul><h2 id="CMQ"><a href="#CMQ" class="headerlink" title="CMQ"></a>CMQ</h2><p>消息队列 CMQ 支持 Pull（队列） 和 Push（主题） 两种方式：</p><ul><li>Push 模型：当 Producer 发出的消息到达后，服务端马上将这条消息投递给 Consumer。</li><li>Pull 模型：当服务端收到这条消息后什么也不做，只是等着 Consumer 主动到自己这里来读，即 Consumer 这里有一个“拉取”的动作。<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ruby-china.org/topics/26221" target="_blank" rel="noopener">吞吐量、QPS、TPS</a><br><a href="https://www.jianshu.com/p/689ce4205021" target="_blank" rel="noopener">消息队列简介</a><br><a href="https://cloud.tencent.com/document/api/406/5851" target="_blank" rel="noopener">CMQ API</a><br><a href="https://cloud.tencent.com/document/product/406" target="_blank" rel="noopener">CMQ 文档中心</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png&quot; alt=&quot;hh&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="CMQ" scheme="http://yoursite.com/tags/CMQ/"/>
    
  </entry>
  
  <entry>
    <title>pm2工作使用</title>
    <link href="http://yoursite.com/2019/09/13/pm2%E5%B7%A5%E4%BD%9C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/13/pm2工作使用/</id>
    <published>2019-09-13T09:25:25.000Z</published>
    <updated>2019-11-27T08:56:58.242Z</updated>
    
    <content type="html"><![CDATA[<p>pm2 基本知识及常用命令</p><a id="more"></a><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><pre><code>配置文件里的设置项，跟命令行参数基本是一一对应的。可以选择yaml或者json文件，就看个人洗好了。json格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如--env）PM2配置文件夹结构    一旦PM2启动，自动创建这些文件夹：$HOME/.pm2 将包含所有与PM2相关的文件$HOME/.pm2/logs 将包含所有应用程序日志  // out标准输出  error 错误输出$HOME/.pm2/pids 将包含所有应用程序pid$HOME/.pm2/pm2.log PM2日志  // pm2自身日志，如谁用了那个命令$HOME/.pm2/pm2.pid PM2 pid$HOME/.pm2/rpc.sock 远程命令的套接字文件$HOME/.pm2/pub.sock 用于可发布事件的套接字文件$HOME/.pm2/conf.js PM2配置</code></pre><h5 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h5><pre><code>配置pm2启动文件  生成示例生态系统.json文件，其中列出了进程和部署环境$ pm2 ecosystem；这将生成一个示例ecosystem.config.js根据需要再次编辑文件{  &quot;apps&quot;: [  // json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用    {      &quot;name&quot;: &quot;mywork&quot;,  // 应用程序名称      &quot;cwd&quot;: &quot;/srv/node-app/current&quot;,  // 应用程序所在的目录      &quot;script&quot;: &quot;bin/www&quot;,  // 应用程序的脚本路径      &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm Z&quot;,        &quot;error_file&quot;: &quot;/var/log/node-app/node-app.stderr.log&quot;,  // 错误日志      &quot;out_file&quot;: &quot;log/node-app.stdout.log&quot;,  //  自定义应用程序日志文件      &quot;pid_file&quot;: &quot;pids/node-geo-api.pid&quot;,  // 自定义应用程序的pid文件      &quot;instances&quot;: 6,      &quot;min_uptime&quot;: &quot;200s&quot;,  // 最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量      &quot;max_restarts&quot;: 10,    // 设置应用程序异常退出重启的次数，默认15次（从0开始计数）      &quot;max_memory_restart&quot;: &quot;1M&quot;,  // 服务内存超过1M，会自动重启      &quot;cron_restart&quot;: &quot;1 0 * * *&quot;,  // 定时启动，解决重启能解决的问题      &quot;watch&quot;: false,  // 监听重启，启用情况下，文件夹或子文件夹下变化应用自动重启；      &quot;merge_logs&quot;: true,      &quot;exec_interpreter&quot;: &quot;node&quot;,      &quot;exec_mode&quot;: &quot;fork&quot;,  // 应用启动模式，支持fork和cluster模式；      &quot;autorestart&quot;: false,  // 默认为true, 发生异常的情况下自动重启；      &quot;vizion&quot;: false    }  ]}</code></pre><h3 id="工作常用命令"><a href="#工作常用命令" class="headerlink" title="工作常用命令"></a>工作常用命令</h3><pre><code>启动项目：pm2 start ecosystem.config.js--env development实时日志打印：pm2 logs youke查看项目状态：pm2 show youke停止项目：pm2 stop youke</code></pre><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><pre><code>重启：pm2 restart ecosystem.config.jspm2 reload；与restart杀死并重新启动进程的相对，reload实现了0秒的停机时间重载。pm2 [list|ls|l|status]查看启动程序的详细信息：pm2 describe idpm2 monit：可以得到进程(以及集群)的CPU的使用率和内存占用(ctrl +c 退出)启动项目：pm2 start ecosystem.config.js --watch--watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。-i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。--ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。        比如--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;-n --name：应用的名称。查看应用信息的时候可以用到。-o --output &lt;path&gt;：标准输出日志文件的路径。-e --error &lt;path&gt;：错误输出日志文件的路径。</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://wohugb.gitbooks.io/pm2/content/bu_shu.html" target="_blank" rel="noopener">pm2教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pm2 基本知识及常用命令&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pm2" scheme="http://yoursite.com/tags/pm2/"/>
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>多媒体&amp;FFmpeg命令</title>
    <link href="http://yoursite.com/2019/09/13/%E5%A4%9A%E5%AA%92%E4%BD%93&amp;FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/09/13/多媒体&amp;FFmpeg常用命令/</id>
    <published>2019-09-13T09:25:25.000Z</published>
    <updated>2019-11-27T08:52:16.026Z</updated>
    
    <content type="html"><![CDATA[<p>多媒体基本概念及 FFmpeg 常用命令介绍</p><a id="more"></a><h3 id="多媒体基本概念"><a href="#多媒体基本概念" class="headerlink" title="多媒体基本概念"></a>多媒体基本概念</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><pre><code>容器(Container)——容器就是一种文件格式，比如flv，mkv等。包含下面5种流以及文件头信息。流(Stream)——是一种视频数据信息的传输方式，5种流：音频，视频，字幕，附件，数据。帧(Frame)——帧代表一幅静止的图像，分为I帧，P帧，B帧。编解码器(Codec)——是对视频进行压缩或者解压缩，CODEC =COde （编码） +DECode（解码）复用/解复用(mux/demux)——把不同的流按照某种容器的规则放入容器，这种行为叫做复用（mux）把不同的流从某种容器中解析出来，这种行为叫做解复用(demux)采样率：录音设备在一秒钟内对声音信号的采样次数，采样频率越高声音的还原就越真实越自然。采样频率一般共分为22.05KHz、44.1KHz、48KHz三个等级。8KHz - 电话所用采样率, 对于人的说话已经足够，22.05KHz只能达到FM广播的声音品质，44.1KHz则是理论上的CD音质界限，48KHz则更加精确一些。采样位数：记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。声道数：声道数是指支持能不同发声的音响的个数，它是衡量音响设备的重要指标之一。单声道的声道数为1个声道；双声道的声道数为2个声道；立体声道的声道数默认为2个声道；立体声道（4声道）的声道数为4个声道。码率：码率 = 采样率 * 采样位数 * 声道数如果是CD音质，采样率44.1KHz，采样位数16bit，立体声(双声道)，码率 = 44.1 * 16 * 2 = 1411.2Kbps = 176.4KBps，那么录制一分钟的音乐，大概10.34MB。音频帧：音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的。编码：通过一定协议或规则把一段声音或图像转化成计算机数字文件的过程。音频编码：将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。常见的音频编码方案有AAC、MP3、WMA。 AAC原始码流（又称为“裸流”）是由一个一个的ADTS frame组成的。解码：编码的逆过程，把编码过的媒体文件重新转化成声音或图像。</code></pre><h5 id="视频基本概念"><a href="#视频基本概念" class="headerlink" title="视频基本概念"></a>视频基本概念</h5><pre><code>视频：静止的画面叫图像（picture）。连续的图像变化每秒超过24帧（frame）画面以上时，根椐视觉暂留原理，人眼无法辨别每幅单独的静态画面，看上去是平滑连续的视觉效果。这样的连续画面叫视频。当连续图像变化每秒低于24帧画面时，人眼有不连续的感觉叫动画（cartoon）。帧率：帧/秒（frames per second）的缩写，也称为帧速率，测量用于保存、显示动态视频的信息数量。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象。每秒钟帧数 （fps） 愈多，所显示的动作就会愈流畅，可理解为秒钟时间里刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，也就是指每秒钟能够播放（或者录制）多少格画面。分辨率：一个表示平面图像精细程度的概念，通常它是以横向和纵向点的数量来衡量的，表示成水平点数垂直点数的形式，在计算机显示领域我们也表示成“每英寸像素”（ppi）。在一个固定的平面内，分辨率越高，意味着可使用的点数越多，图像越细致。</code></pre><h5 id="M3U8-amp-HLS"><a href="#M3U8-amp-HLS" class="headerlink" title="M3U8 &amp; HLS"></a>M3U8 &amp; HLS</h5><pre><code>M3U8是一种常见的流媒体格式，主要以文件列表的形式存在，既支持直播又支持点播HLS（全称：Http Live Streaming）是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分：        一是M3U8描述文件：是指UTF-8编码格式的M3U文件。M3U文件是记录了一个索引纯文本文件，打开它时播放软件并不是播放它，而是根据它的索引找到对应的音视频文件的网络地址进行在线播放。        二是TS(Transport Stream)媒体文件：为什么要用 TS 而不是 MP4？这是因为两个 TS 片段可以无缝拼接，播放器能连续播放，而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接，连续播放会产生破音和画面间断</code></pre><h5 id="MP3-amp-AAC-区别"><a href="#MP3-amp-AAC-区别" class="headerlink" title="MP3 &amp; AAC 区别"></a>MP3 &amp; AAC 区别</h5><pre><code>MP3和AAC都是音频格式，后者是前者的进化版MP3：MP3是一种数字音乐格式，可以将CD轨道减小到其正常大小的十分之一左右，而不会明显降低质量。，MP3高频数据丢失严重AAC：AAC与MP3相似。它实质上可以切出或压缩人耳无法拾取的信息，从而使数字文件更小，更易于管理，因此下载速度更快。AAC的大小约为MP3的一半，但质量更高。压缩程度更高,提升压缩率，支持多声道，更高的解析度，提升的解码效率。相比MP3音质和占有空间更小ADTS全称是(Audio Data Transport Stream)，是AAC的一种十分常见的传输格式。</code></pre><h5 id="常见音频格式"><a href="#常见音频格式" class="headerlink" title="常见音频格式"></a>常见音频格式</h5><pre><code>有损格式主要有MP3, WMA, OGG, MP3pro, AAC, VQF, ASF等。无损：WAV</code></pre><h2 id="FFmpeg-常用命令"><a href="#FFmpeg-常用命令" class="headerlink" title="FFmpeg 常用命令"></a>FFmpeg 常用命令</h2><pre><code>-y 覆盖输出文件，若存在不提示覆盖。-f 输出hls格式。hls协议流媒体网络传输协议：hls_list_size 3:HLS播放的列表，FFmpeg默认5。-hls_time 1:设置M3U8列表中切片的duration,每一片TS文件时长1秒左右。-hls_wrap 10:表示为最大的TS循环数，10个，每10个一个循环-ar freq 设置音频采样率 -ac channels 设置通道 缺省为与输入相同 -acodec 使用pcm_s16le编码</code></pre><h2 id="FFmpeg常用操作"><a href="#FFmpeg常用操作" class="headerlink" title="FFmpeg常用操作"></a>FFmpeg常用操作</h2><ul><li>合并多段音频</li></ul><p><code>ffmpeg -y -i &quot;concat:${pathList.join(&#39;|&#39;)}&quot; -acodec copy part_all.aac</code> 注：pathlist为多段音频地址<br>参数： -acodec copy表示使用跟原视频一样的音频编解码器</p><ul><li>aac =&gt; mp3</li></ul><p><code>ffmpeg -y -i &#39;${filePrefix}all${version}.aac&#39; &#39;${filePrefix}all${version}.mp3&#39;</code></p><ul><li>一段音频剪切中间一段</li></ul><p><code>ffmpeg -i part_all4.mp3 -filter_complex &quot;[0]atrim=duration=start_pos[a];[0]atrim=start=end_pos[b];[a][b]concat=n=2:v=0:a=1&quot; output.mp3</code>  注：start_pos起始位置 end_pos终止位置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多媒体基本概念及 FFmpeg 常用命令介绍&lt;/p&gt;
    
    </summary>
    
    
      <category term="多媒体" scheme="http://yoursite.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
    
      <category term="多媒体" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>腾讯COS项目记录</title>
    <link href="http://yoursite.com/2019/09/12/%E8%85%BE%E8%AE%AFCOS/"/>
    <id>http://yoursite.com/2019/09/12/腾讯COS/</id>
    <published>2019-09-12T07:25:25.000Z</published>
    <updated>2019-11-27T08:54:49.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-master-nodejs"><a href="#https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-master-nodejs" class="headerlink" title="https://github.com/tencentyun/qcloud-cos-sts-sdk/tree/master/nodejs"></a><a href="https://github.com/tencentyun/qcloud-cos-sts-sdk/tree/master/nodejs" target="_blank" rel="noopener">https://github.com/tencentyun/qcloud-cos-sts-sdk/tree/master/nodejs</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-master-nodejs&quot;&gt;&lt;a href=&quot;#https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-mas
      
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="多媒体" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>node学习</title>
    <link href="http://yoursite.com/2019/09/05/node%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/09/05/node学习/</id>
    <published>2019-09-05T07:25:25.000Z</published>
    <updated>2019-11-27T09:13:28.162Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li><p>for 或者 foreach 进行循环获取数组值<br>var array = [‘a’, ‘b’, ‘c’, ‘d’];<br>for (var i = 0; i &lt; array.length; i++)<br>array.forEach(function (element)</p></li><li><p>for..in 遍历对象属性（或索引）<br>for (var key in array)</p></li></ul><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p><a href="https://blog.csdn.net/cvper/article/details/79543262" target="_blank" rel="noopener">查看包版本</a><br>假设现在我们已经成功下载了jquery，过了一段时间，我忘记了下载的jquery的版本信息</p><p>第一种方式：npm ls jquery 即可（查看本地安装的jQuery），下面我的本地没有安装jquery，<br>第二种方式：npm ls jquery -g    (查看全局安装的jquery)</p><p>npm install packageName –save //安装到项目目录下，并在package.json文件的dependencies中写入依赖，简写为-S</p><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>参考：<br><a href="https://itbilu.com/nodejs/npm/VJHw6ScNb.html" target="_blank" rel="noopener">bluebird与原生Promise对象及bluebird模块的中文API文档</a><br><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">Promise迷你书</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>俩个特点：</p><ul><li>对象的状态不受外界影响，只有异步操作的结果可决定状态，pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ul><p>在NodeJS中用于替代回调函数，在使用NodeJS的KOA框架时可使用Promise来代替回调函数。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>new Promise - 创建实例<br>new Promise(function(function resolve, function reject) resolver) -&gt; Promise</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直接调用.catch方法。</p><h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async&amp;await"></a>async&amp;await</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>await:表示等待 Promise 返回结果，在继续执行。<br>async:由于nodejs是异步编程模型，有一些在同步编程中很容易做到的事情，现在却变得很麻烦。async的流程控制就是为了简化这些操作。</p><p>返回值是一个Promise对象，使用then方法添加回调函数<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p><ul><li>在函数体前通过关键字async可以将函数变为async函数</li><li>在async函数中对需要异步执行的函数前需加await关键字</li><li>await后的函数必须使用Promise对象封装</li><li>async函数执行后返回的是一个Promise对象</li></ul><h2 id="node-的单线程"><a href="#node-的单线程" class="headerlink" title="node 的单线程"></a>node 的单线程</h2><p>node.js单线程只是一个js主线程，本质上的异步操作还是由线程池完成的，node将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，</p><p>并没有进行真正的I/O操作，从而实现异步非阻塞I/O。</p><p>重点在主线程为单线程，主线程执行代码形成一个执行栈</p><p>主线程之外维护一个事件队列，当IO或异步操作，会将事件放到Event queue中，并不会执行且继续执行主线程代码，不会阻塞，直到主线程代码完毕。</p><p>主线程执行完毕，循环去取事件，用线程池线程去执行事件。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。</p><p>一定注意异步问题，可使用promise，实现代码如下</p><pre><code>// 遇到需要同步执行的代码，promise化，await执行，外层一定要有asyncfunction formImage() {    return new Promise((resolve, reject) =&gt; {        form((opt, {fields, files})=&gt; {            console.log(files)            let filename = files.file.name            console.log(files.file.path)            let uploadDir = config.ROOTPATH + `/tmp/${roomId}/`            let relativePath =  `/tmp/${roomId}/` + Date.now() + &#39;_&#39; + filename            mkdirs(uploadDir, () =&gt; {                fs.renameSync(files.file.path, config.ROOTPATH + relativePath) //重命名                resolve(relativePath)            })        })    })}let p = await formImage();</code></pre><p>Node.js等则规定在JavaScript的回调函数的第一个参数为 Error 对象，这也是它的一个惯例。</p><p>class：constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>调用要用 new Class()</p><h2 id="事件驱动的过程"><a href="#事件驱动的过程" class="headerlink" title="事件驱动的过程"></a>事件驱动的过程</h2><p>所有的东西包装成一个对象，执行了一个事件循环</p><p>​事件驱动，把所有的东西都当成一个事件</p><p>while(true){<br>  // 无限循环<br>}<br>不同的异步，不同的优先级</p><p>while(true){<br>    第一步： 执行script(全部的代码)<br>    先去清空micor-task队列的事件，去把这里面的全部执行完<br>    再去找 setInterval 执行 再去清空micor-task队列<br>    再去找 setImmediate 执行，再去清空micor-task队列<br>    再去 I/O 操作  再去清空micro-task队列<br>}<br>虽然都是异步，但是是有优先级的</p><p>macro-task:队列 script(全部的代码)</p><p>script(全部的代码) setInterval()  setTimeout() setImmediate() I/O操作（读写，查询数据库）<br>他们都是同步的，但是他们的回调函数是异步的<br>micro-task:队列</p><p>process.nextTick()  Promise().then()<br>注意 setInterval()和setTimeout()优先级是一样的</p><p>异步事件的优先级</p><p>nextTick &gt; Promise.then &gt; setTimeout &gt; setImmediate</p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="Node-js时间戳和日期互相转换"><a href="#Node-js时间戳和日期互相转换" class="headerlink" title="Node.js时间戳和日期互相转换"></a>Node.js时间戳和日期互相转换</h3><ul><li><p>日期转时间戳<br>var date = new Date(“2018-11-20 18:08:00”);<br>var time = date.getTime()/1000;//转换成秒；  getTime() =&gt; 转化为时间戳</p></li><li><p>时间戳转日期<br>var time = 1542708681;<br>// 也可以获取当前的毫秒级时间戳<br>var time2 = Date.now();<br>var date = new Date(time * 1000);<br>var dt = date.getFullYear() + “-“ + (date.getMonth() &lt; 10 ? ‘0’ + (date.getMonth()+1) : (date.getMonth()+1)) + “-“ + (date.getDate() &lt; 10 ? ‘0’ + date.getDate() : date.getDate()) ;</p></li></ul><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><a href="https://www.jianshu.com/p/b240051784ab" target="_blank" rel="noopener">node-request模块</a></p><pre><code>request({    url: url,    type: &#39;post&#39;    encoding: &#39;utf-8&#39;,  // utf-8则 body为string，为null则为buffer，}, async function(error, response, body) {    resolve(body)})</code></pre><h3 id="xml2js-xml-json-相互转化"><a href="#xml2js-xml-json-相互转化" class="headerlink" title="xml2js - xml json 相互转化"></a>xml2js - xml json 相互转化</h3><p>安装：npm install xml2js</p><p>使用：</p><p>  var xml2js = require(‘xml2js’);</p><p>  var builder = new xml2js.Builder();  // JSON-&gt;xml<br>  var parser = new xml2js.Parser();   //xml -&gt; json</p><p>  var json =  parser.parseString（xml）;</p><p>  。。。。。</p><p>  xml =  builder.buildObject（json）;</p><h3 id="koa2"><a href="#koa2" class="headerlink" title="koa2"></a>koa2</h3><p>web框架。koa中间件，中间件的通过next函数联系,执行next()后会将控制权交给下一个中间件,如果没有中间件没有执行next后将会沿路折返,将控制权交换给前一个中间件。<br>ctx封装了request 和response对象<br>ctx.state  推荐的命名空间，用于通过中间件传递信息和你的前端视图</p><ul><li>get请求参数获取：</li></ul><p>1.是从上下文中直接获取<br>请求对象ctx.query，返回如 { a:1, b:2 }<br>请求字符串 ctx.querystring，返回如 a=1&amp;b=2<br>2.是从上下文的request对象中获取<br>请求对象ctx.request.query，返回如 { a:1, b:2 }<br>请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2</p><ul><li>POST请求参数获取：</li></ul><p>注意：ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象，<br>同理ctx.response是context经过封装的响应对象，ctx.res是context提供的node.js原生HTTP请求对象。</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>Buffer是node的核心模块，开发者可以利用它来处理二进制数据，比如文件流的读写、网络请求数据的处理等。</p><p>创建：<br>new Buffer(array)<br>Buffer.alloc(length)<br>Buffer.allocUnsafe(length)<br>Buffer.from(array)</p><h3 id="bluebird"><a href="#bluebird" class="headerlink" title="bluebird"></a>bluebird</h3><p>Bluebird 的 Promise.promisifyAll 方法可以为一个对象的属性中的所有方法创建一个对应的使用 Promise 的版本。这些新创建方法的名称在已有方法的名称后加上”Async”后缀。</p><ul><li>用法：<br>const bluebird = require(‘bluebird’)<br>bluebird.promisifyAll(fs)</li></ul><p>如果不希望把一个对象的所有方法都自动转换成使用 Promise 的形式，可以使用 Promise.promisify 来转换单个方法，如 Promise.promisify(require(“fs”).readFile)。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://elemefe.github.io/node-interview/#/sections/zh-cn/" target="_blank" rel="noopener">饿了么面试</a><br><a href="https://juejin.im/post/5940a9c3128fe1006a0ab176" target="_blank" rel="noopener">node流的概念</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;for 或者 foreach 进行循环获取数组值&lt;br&gt;var ar
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>记录一次小程序开发</title>
    <link href="http://yoursite.com/2019/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/26/小程序项目记录/</id>
    <published>2019-08-26T07:25:25.000Z</published>
    <updated>2019-11-27T09:09:07.189Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次小程序开发，出现的坑以及一些知识</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>openID：不同APP不同openID。用户唯一标识，跟人一一对应，小程序分配给每个人的ID  OpenID = 用户微信号 &amp; 公众平台APPID（两个数据加密得到的字符串）  不同公众号不同ID</p></li><li><p>unionID：即使不同应用，ID一样。通过获取用户基本信息接口，开发者可通过OpenID来获取用户基本信息</p></li><li><p>appID(小程序ID):它其实就是小程序的「身份证号码」</p></li><li><p>AppSecret(小程序密钥)</p></li><li><p>PV：分享给了多少人</p></li><li><p>UV：分享的课程被多少人打开</p></li><li><p>openGid：小程序的群唯一标识的id</p></li></ul><h2 id="微信内容校验-node-实现"><a href="#微信内容校验-node-实现" class="headerlink" title="微信内容校验 node 实现"></a>微信内容校验 node 实现</h2><h2 id="利用-puppeteer-可以生成一个网页的图片"><a href="#利用-puppeteer-可以生成一个网页的图片" class="headerlink" title="利用 puppeteer 可以生成一个网页的图片"></a>利用 puppeteer 可以生成一个网页的图片</h2><p><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" target="_blank" rel="noopener">参考文档</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>node没有原生的取POST请求体<br>koa中可以利用 koa-body，如：router.post(‘/del_room’, <strong>koaBody()</strong>, async (ctx)</li></ul><p><strong>但是</strong>取xml koa-body不行，可以从原生的数据中读取<br>如：</p><pre><code>getPostData = function (ctx) {    return new Promise((resolve, reject) =&gt; {        var data = &quot;&quot;;        ctx.req.on(&quot;data&quot;, chunk =&gt; data += chunk);        ctx.req.on(&quot;end&quot;, () =&gt; resolve(data))        ctx.req.on(&quot;error&quot;, err =&gt; reject(err))        }    )}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次小程序开发，出现的坑以及一些知识&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="http://yoursite.com/2019/08/20/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/08/20/面试总结/</id>
    <published>2019-08-20T07:25:25.000Z</published>
    <updated>2019-11-27T08:53:43.026Z</updated>
    
    <content type="html"><![CDATA[<p>关于面试的点点滴滴</p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://yangshun.github.io/tech-interview-handbook/coding-round-overview" target="_blank" rel="noopener">如何准备编程面试</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/cheatsheet" target="_blank" rel="noopener">面试备忘录</a>：涉及面试前需要准备的问题，收到面试题的考虑方式、编程测试准备流程、面试总结</li><li><a href="https://yangshun.github.io/tech-interview-handbook/algorithms/algorithms-introduction" target="_blank" rel="noopener">算法小贴士</a>：各类算法小贴士，以及按主题分类过的最容易考到的问题</li><li><a href="https://github.com/yangshun/front-end-interview-handbook" target="_blank" rel="noopener">前端求职面试问题答案</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/company-interview-formats" target="_blank" rel="noopener">互联网大厂的面试形式解析</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/behavioral-questions" target="_blank" rel="noopener">科技巨头们的通用常见问题，以及几个大厂的常见通用非技术问题</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/questions-to-ask" target="_blank" rel="noopener">适合在面试结束时问考官的好问题！</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/resume" target="_blank" rel="noopener">做简历注意事项，让你的简历更能引起面试官注意</a></li><li><a href="http://www.cjjjs.com/page/topicinfo?id_topic=63" target="_blank" rel="noopener">面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于面试的点点滴滴&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>工作问题记录</title>
    <link href="http://yoursite.com/2019/08/15/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/08/15/工作问题记录/</id>
    <published>2019-08-15T09:25:25.000Z</published>
    <updated>2019-11-27T08:51:36.835Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p>URL特殊字符转译问题：<br>在拼接url的时候，需将特殊字符转译，<a href="https://blog.csdn.net/p312011150/article/details/78928003" target="_blank" rel="noopener">参考</a></p><p>提取图片里的文字：可以使用OCR 光学字符识别（英語：Optical Character Recognition）</p><p>一定不要相信前端传来的东西，都需要进行校验</p><p>node 中 HTTP 接口拿不到 xml 对象<br>function getPostData (ctx) {<br>    return new Promise((resolve, reject) =&gt; {<br>        var data = “”;<br>        ctx.req.on(“data”, chunk =&gt; data += chunk);<br>        ctx.req.on(“end”, () =&gt; resolve(data))<br>        ctx.req.on(“error”, err =&gt; reject(err))<br>        }<br>    )<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="工作" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>小知识总结</title>
    <link href="http://yoursite.com/2019/07/16/%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/16/小知识总结/</id>
    <published>2019-07-16T09:25:25.000Z</published>
    <updated>2019-11-27T09:02:38.906Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="工作中"><a href="#工作中" class="headerlink" title="工作中"></a>工作中</h2><p><a href="http://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html" target="_blank" rel="noopener">HTTPS 升级指南</a><br><a href="https://blog.csdn.net/qq_41307443/article/details/79839558" target="_blank" rel="noopener">MySQL Windows 安装</a><br><a href=""></a></p><h2 id="一句话知识"><a href="#一句话知识" class="headerlink" title="一句话知识"></a>一句话知识</h2><p>PNG 比 JPEG 格式质量好，占空间，同一张图片 PNG 26M，JPEG 为 4 M<br>可移植性就是可以在多个系统运使用行<br>request 请求接口时，发起一个带证书的请求，用法如下所示：</p><pre><code>let opt = {        url:&quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&quot;,        body:sendData,        key: fs.readFileSync(&#39;./config/apiclient_key.pem&#39;), // 将微信生成的证书放入 cert目录下        cert: fs.readFileSync(&#39;./config/apiclient_cert.pem&#39;),        // ca:fs.readFileSync(&#39;./config/apiclient_cert.p12&#39;)    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小知识" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>sentos相关</title>
    <link href="http://yoursite.com/2019/07/08/sentos%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/07/08/sentos相关/</id>
    <published>2019-07-08T09:25:25.000Z</published>
    <updated>2019-11-27T08:57:31.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>查看位数：getconf LONG_BIT<br>查看版本：cat /etc/redhat-release</p><h2 id="rpm和yum的关系以及基本用法"><a href="#rpm和yum的关系以及基本用法" class="headerlink" title="rpm和yum的关系以及基本用法"></a>rpm和yum的关系以及基本用法</h2><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h3><p>RPM是RedHat Package Manager（RedHat软件包管理工具）类似Windows里面的“添加/删除程序”<br>rpm 执行安装包<br>二进制包（Binary）以及源代码包（Source）两种。二进制包可以直接安装在计算机中，而源代码包将会由RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。</p><h4 id="解压-rpm-包"><a href="#解压-rpm-包" class="headerlink" title="解压 rpm 包"></a>解压 rpm 包</h4><p>RPM包括是使用cpio格式打包的，因此可以先转成cpio然后解压，如下所示：<br>rpm2cpio xxx.rpm | cpio -div<br>解压后 里面会有 .spec 文件，是该包的描述文件</p><h3 id="Yum"><a href="#Yum" class="headerlink" title="Yum"></a>Yum</h3><p>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理 依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断。</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul><li>源码安装<br>源码的安装一般由3个步骤组成：配置(configure)、编译(make)、安装(make install)。</li></ul><pre><code>$ tar zxvf XXXX.tar.gz (or tar jxvf XXXX.tar.bz2)$ cd XXXX$ ./configure$ make$ make install</code></pre><p>清理安装后的临时文件：</p><blockquote><p>$ make clean</p></blockquote><p>卸载软件</p><blockquote><p>make uninstall</p></blockquote><h4 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h4><p>1、 下载源码包<br>2、 解压包<br>3、 设置软件的安装目录：$ ./configure –prefix=/opt/XXX<br>检查configure返回结果，为0代表运行成功：</p><blockquote><p>$ echo $?<br>0</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kancloud.cn/chandler/bc-linux/55602" target="_blank" rel="noopener">linux笔记</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-rpm/index.html" target="_blank" rel="noopener">RPM 打包技术与典型 SPEC 文件分析</a><br><a href="https://blog.csdn.net/huangfei711/article/details/53044539" target="_blank" rel="noopener">添加环境变量</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>vim常用操作</title>
    <link href="http://yoursite.com/2019/07/06/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/07/06/vim常用操作/</id>
    <published>2019-07-06T01:48:05.000Z</published>
    <updated>2019-11-27T08:57:56.691Z</updated>
    
    <content type="html"><![CDATA[<p>vim  工作常用命令</p><a id="more"></a><p><a href="https://vimsky.com/wp-content/uploads/2015/03/131.jpg" target="_blank" rel="noopener">vim 常用总结图片</a></p><h2 id="工作常用"><a href="#工作常用" class="headerlink" title="工作常用"></a>工作常用</h2><ul><li>查找替换<pre><code>/text　　查找text，n下一个，N前一个?text　　查找text，反向查找，n下一个，N前一个</code></pre></li></ul><p>ra 将当前字符替换为a，当期字符即光标所在字符。<br>:s/old/new/ 用old替换new，替换当前行的第一个匹配<br>:s/old/new/g 用old替换new，替换当前行的所有匹配<br>:%s/old/new/ 用old替换new，替换所有行的第一个匹配<br>:%s/old/new/g 用old替换new，替换整个文件的所有匹配</p><pre><code>- 复制粘贴</code></pre><p>dd    删除光标所在行<br>x    删除当前字符<br>yy    复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行<br>p    粘贴粘贴板的内容到当前行的下面  大P 为上面</p><pre><code>- 移动光标</code></pre><p>h,j,k,l    上，下，左，右<br>gg → 到第一行<br>G → 到最后一行</p><pre><code>## 常见用法</code></pre><p>i → Insert 模式，按 ESC 回到 Normal 模式.<br>x → 删当前光标所在的一个字符。<br>dd → 删除当前行，并把删除的行存到剪贴板里<br>p → 粘贴剪贴板</p><p>normal模式下：<br>插入：a → 在光标后插入  o → 在当前行后插入一个新行  O → 在当前行前插入一个新行  cw → 替换从光标所在位置后到一个单词结尾的字符<br>移动光标：0 → 数字零，到行头    ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）<br>$ → 到本行行尾    g_ → 到本行最后一个不是blank字符的位置。<br>/pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）<br>拷贝/粘贴：P → 粘贴  p是表示在当前位置之后，P表示在当前位置之前<br>w → 到下一个单词的开头。<br>e → 到下一个单词的结尾。</p><p>撤销与重做<br>u           撤销（Undo）<br>U           撤销对整行的操作<br>Ctrl + r    重做（Redo），即撤销的撤销</p><p>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim  工作常用命令&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="命令" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>ROM&amp;RAM&amp;FLASH</title>
    <link href="http://yoursite.com/2019/06/13/ROM&amp;RAM&amp;FLASH/"/>
    <id>http://yoursite.com/2019/06/13/ROM&amp;RAM&amp;FLASH/</id>
    <published>2019-06-13T09:25:25.000Z</published>
    <updated>2019-11-27T08:57:06.762Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"><br>初学MCU的人，经常会看到ROM, RAM, FLASH，而且会被这些词汇搞得晕头转向。本文对这些概念进行了厘清，并介绍了这些Memory的区别</p><p><strong>备注</strong>：MCU-单片机，微型计算机</p><a id="more"></a><h2 id="ROM-Read-Only-Memory-程序存储器"><a href="#ROM-Read-Only-Memory-程序存储器" class="headerlink" title="ROM (Read Only Memory)程序存储器"></a>ROM (Read Only Memory)程序存储器</h2><p>它是一种只能读出事先所存的数据的固态半导体存储器。ROM中所存数据稳定，一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失。其结构简单，因而常用于存储各种固化程序和数据。</p><h2 id="RAM-Random-Access-Memory-随机访问存储器"><a href="#RAM-Random-Access-Memory-随机访问存储器" class="headerlink" title="RAM (Random Access Memory)随机访问存储器"></a>RAM (Random Access Memory)随机访问存储器</h2><p>RAM又称随机存取存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序。</p><p>它主要用来存储程序中用到的变量。凡是整个程序中，所用到的需要被改写的量（包括全局变量、局部变量、堆栈段等），都存储在RAM中。</p><h2 id="ROM-amp-RAM区别"><a href="#ROM-amp-RAM区别" class="headerlink" title="ROM&amp;RAM区别"></a>ROM&amp;RAM区别</h2><p><a href="https://blog.csdn.net/szupjz/article/details/51842242" target="_blank" rel="noopener">参考</a></p><p>通俗的说，比如在电脑中，大家都知道有内存和硬盘之说，其实内存就是一种RAM技术，而ROM则类似于硬盘技术，两者都是存储器，只是RAM的速度要远远高于ROM的速度。</p><p>在电脑日常操作中，很多程序都将临时运行的程序命令，存放在内存中，但一旦关机或者停电，内存里原本临时存储的程序信息将全部被清空，也就是内存只能临时存储东西，不能长久保存，而ROM则可以存储，即使掉电后也可以找到之前存储的文件，这也就是硬盘了。</p><h2 id="FLASH-存储器"><a href="#FLASH-存储器" class="headerlink" title="FLASH 存储器"></a>FLASH 存储器</h2><p>Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区（block）操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;初学MCU的人，经常会看到ROM, RAM, FLASH，而且会被这些词汇搞得晕头转向。本文对这些概念进行了厘清，并介绍了这些Memory的区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：MCU-单片机，微型计算机&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>数组&amp;链表</title>
    <link href="http://yoursite.com/2019/06/13/%E6%95%B0%E7%BB%84&amp;%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/06/13/数组&amp;链表/</id>
    <published>2019-06-13T09:25:25.000Z</published>
    <updated>2019-11-27T08:54:25.018Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组（Array）是一种线性表数据结构。它用一组连续的内存</p><p>为什么数组下标从0开始？<br>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>理解高性能网络模型</title>
    <link href="http://yoursite.com/2019/06/11/%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/06/11/理解高性能网络模型/</id>
    <published>2019-06-11T09:25:25.000Z</published>
    <updated>2019-11-27T08:53:26.362Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://yoursite.com/2019/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/11/数据结构与算法/</id>
    <published>2019-06-11T09:25:25.000Z</published>
    <updated>2019-11-27T09:19:13.893Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p><a href="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126033120%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%E5%9B%BE.jpg" target="_blank" rel="noopener">总览图</a><br><a href="https://github.com/wangzheng0822/algo/tree/master/python" target="_blank" rel="noopener">wangzheng GitHub</a><br><a href="https://visualgo.net/en" target="_blank" rel="noopener">各种排序演示图</a><br><a href="https://www.bilibili.com/video/av685670" target="_blank" rel="noopener">b站学习</a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ol><li>数据结构是指一组数据的存储结构</li><li>算法就是操作数据的方法</li><li>数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法要作用在特定的数据结构之上</li></ol><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。<br>从狭义上讲，指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。<br>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p><ol><li>数据结构和算法学习的精髓-复杂度分析</li><li>最常用的、最基础的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</li><li>最常用的算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法<h2 id="为什么学"><a href="#为什么学" class="headerlink" title="为什么学"></a>为什么学</h2></li><li>直接好处是能够有写出性能更优的代码。</li><li>算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。</li><li>长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。</li></ol><h2 id="如何学"><a href="#如何学" class="headerlink" title="如何学"></a>如何学</h2><ol><li>一定要动手写</li><li>千万不要被动地记忆，要多辩证地思考，多问为什么。</li><li>边学边练，适度刷题  多问、多思考、多互动</li><li>知识需要沉淀，不要想试图一下子掌握所有</li><li>结合实际：排个队想到队列，火车进站想到堆栈，看到树上开花想到树的某些指标，导航想到贪心，将生活场景与算法和数据结构的场景结合起来。</li></ol><h3 id="重点学习"><a href="#重点学习" class="headerlink" title="重点学习"></a>重点学习</h3><p>20 个最常用的、最基础数据结构与算法，不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。<br>这里面有 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；<br>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p><p><strong>复杂度分析</strong>是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度又称<strong>渐进时间复杂度</strong>：表示算法的执行时间与数据规模之间的增长关系</p><p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的<strong>存储空间与数据规模</strong>之间的增长关系。</p><h3 id="时间复杂度（重中之中）"><a href="#时间复杂度（重中之中）" class="headerlink" title="时间复杂度（重中之中）"></a>时间复杂度（重中之中）</h3><p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的<strong>变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称时间复杂度。</p><p>PS：即使一段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。</p><p>尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度<br>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积<br>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n)).</li></ol><h4 id="常见的复杂度量级"><a href="#常见的复杂度量级" class="headerlink" title="常见的复杂度量级"></a>常见的复杂度量级</h4><p><img src="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126035226%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg" alt="常见的复杂度量级"><br>我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p><p>主要来看几种常见的多项式时间复杂度。</p><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p><p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><h5 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h5><pre><code>i=1;while (i &lt;= n)  {    i = i * 2;  可为2 3 4 时间复杂度就是 O(log2n) O(log3n)}</code></pre><p>对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C *  log2n)，其中 C=log32 是一个常量。</p><p>基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。</p><p>因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><h5 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h5><p>代码的复杂度由两个数据的规模来决定,从代码中可以看出，m 和 n 是表示两个数据规模。</p><p>我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>全称就是渐进空间复杂度（asymptotic space complexity），表示算法的<strong>存储空间与数据规模</strong>之间的增长关系。</p><pre><code>void print(int n) {  int i = 0;  int[] a = new int[n];  for (i; i &lt;n; ++i) {    a[i] = i * i;  }  for (i = n-1; i &gt;= 0; --i) {    print out a[i]  }}</code></pre><p>第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。</p><p>第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><p>空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p><h3 id="复杂度分类"><a href="#复杂度分类" class="headerlink" title="复杂度分类"></a>复杂度分类</h3><p>四个复杂度分析方面的知识点</p><ul><li>最好情况时间复杂度（best case time complexity）</li><li>最坏情况时间复杂度（worst case time complexity）</li><li>平均情况时间复杂度（average case time complexity）</li><li>均摊时间复杂度（amortized time complexity）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，</p><p>越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。</p><p><img src="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126062213%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90.jpg" alt="复杂度分析"></p><h2 id="指针-amp-引用"><a href="#指针-amp-引用" class="headerlink" title="指针 &amp; 引用"></a>指针 &amp; 引用</h2><p>有些语言有指针的概念，如C；但有的语言没有指针，取而代之的是引用，如Java，Python。实际上意思是一样的，都是存储所指对象的内存地址。</p><p>将某个变量赋值给指针，实际上就是将该变量的地址赋值给该指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</p><p>为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>协议相关</title>
    <link href="http://yoursite.com/2019/05/25/%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/05/25/协议相关/</id>
    <published>2019-05-25T09:25:25.000Z</published>
    <updated>2019-11-27T09:08:11.071Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="Content-type"><a href="#Content-type" class="headerlink" title="Content-type"></a>Content-type</h3><p>是什么？</p><p>是Http的实体首部字段，用于说明请求或返回的消息主体是用何种方式编码，在request header和response header里都存在。</p><p>几种类型：</p><ol><li>application/x-www-form-urlencoded<br>1）浏览器的原生form表单<br>2） 提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key和val都进行了URL转码</li><li>multipart/form-data<br>常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctype 等于这个值。</li><li>application/json<br>消息主体是序列化后的 JSON 字符串,这个类型越来越多地被大家所使用</li><li>text/xml<br>是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范</li></ol><h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>SSL:一种协议，使用通讯双方的客户证书以及CA根证书，允许客户/服务器应用以一种不能被偷听的方式通讯。</p><p>优势：信息加密传播，具有校验机制，配备身份证书<br>TLS是SSL的升级版本</p><p>SSL/TLS协议的基本过程是这样的：</p><p>（1） 客户端向服务器端索要并验证公钥。<br>（2） 双方协商生成”对话密钥”。<br>（3） 双方采用”对话密钥”进行加密通信。</p><p>前俩步被称为握手阶段：</p><ol><li>客户端发出请求 信息：协议版本、随机数用于生成‘对话密钥’、支持的加密方法/压缩方法</li><li>服务器回应 信息：确认版本、随机数同上作用、加密方法、服务器证书</li><li>客户端回应 验证证书、证书中取出公钥。向服务器发送：</li><li>服务器的最后回应</li></ol><p>Telnet是远程连接服务，它工作于在tcp/ip协议的应用层。telnet命令通常用来远程登录。 是Internet远程登陆服务的标准协议和主要方式。 它为用户提供了在本地计算机上完成远程主机工作的能力。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">运行机制的概述</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>计算机专有名词.md</title>
    <link href="http://yoursite.com/2019/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/05/17/计算机专有名词/</id>
    <published>2019-05-17T09:25:25.000Z</published>
    <updated>2019-11-27T08:52:49.420Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p>CVM：云服务器（Cloud Virtual Machine）<br>IPC（Inter-Process Communication，进程间通信）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>密码学</title>
    <link href="http://yoursite.com/2019/05/16/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <id>http://yoursite.com/2019/05/16/密码学/</id>
    <published>2019-05-16T09:25:25.000Z</published>
    <updated>2019-11-27T09:08:04.042Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>摘要（digest）：摘要、hash、散列 有时候会混为一谈，大部分都是一个东西</p><p>将长度不固定的消息作为输入，通过运行hash函数，生成固定长度的输出，这段输出就叫做摘要。通常用来验证消息完整、未被篡改。<br>摘要运算是不可逆的。也就是说，输入固定的情况下，产生固定的输出。但知道输出的情况下，无法反推出输入。</p><p>常见的摘要算法 与 对应的输出位数如下：<br>MD5：128位<br>SHA-1：160位<br>SHA256 ：256位<br>SHA512：512位</p><p>MAC（Message Authentication Code）：消息认证码，用以保证数据的完整性。运算结果取决于消息本身、秘钥。<br>MAC可以有多种不同的实现方式，比如HMAC。<br>HMAC（Hash-based Message Authentication Code）：可以粗略地理解为带秘钥的hash函数。</p><p>对称加密：常见的对称加密算法：DES、3DES、AES、Blowfish、RC5、IDEA。<br>非对称加密：常见的非对称加密算法：RSA、DSA、ElGamal。</p><p>签名：</p><ol><li>确认信息来源于特定的主体。</li><li>确认信息完整、未被篡改。</li></ol><p>发送方生成签名：</p><ol><li>计算原始信息的摘要。</li><li>通过私钥对摘要进行签名，得到电子签名。</li><li>将原始信息、电子签名，发送给接收方。</li></ol><p>伪代码：digest = hash(message); // 计算摘要<br>digitalSignature = sign(digest, priviteKey); // 计算数字签名</p><p>接收方验证签名：</p><ol><li>通过公钥解开电子签名，得到摘要D1。（如果解不开，信息来源主体校验失败）</li><li>计算原始信息的摘要D2。</li><li>对比D1、D2，如果D1等于D2，说明原始信息完整、未被篡改。</li></ol><p>伪代码：digest1 = verify(digitalSignature, publicKey); // 获取摘要<br>digest2 = hash(message); // 计算原始信息的摘要<br>digest1 === digest2 // 验证是否相等</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
</feed>
