<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洋洋&#39;s Blog</title>
  
  <subtitle>Saty Hungry，Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-20T03:13:40.086Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YangYang Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机专有名词.md</title>
    <link href="http://yoursite.com/2019/11/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/11/15/计算机专有名词/</id>
    <published>2019-11-15T09:25:25.000Z</published>
    <updated>2019-11-20T03:13:40.086Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p>CVM：云服务器（Cloud Virtual Machine）<br>IPC（Inter-Process Communication，进程间通信）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>工作问题记录</title>
    <link href="http://yoursite.com/2019/11/15/%E5%B7%A5%E4%BD%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/15/工作问题记录/</id>
    <published>2019-11-15T09:25:25.000Z</published>
    <updated>2019-11-18T02:55:45.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p>URL特殊字符转译问题：<br>在拼接url的时候，需将特殊字符转译，<a href="https://blog.csdn.net/p312011150/article/details/78928003" target="_blank" rel="noopener">参考</a><br>提取图片里的文字：可以使用OCR 光学字符识别（英語：Optical Character Recognition）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="工作" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ROM&amp;RAM&amp;FLASH</title>
    <link href="http://yoursite.com/2019/11/13/ROM&amp;RAM&amp;FLASH/"/>
    <id>http://yoursite.com/2019/11/13/ROM&amp;RAM&amp;FLASH/</id>
    <published>2019-11-13T09:25:25.000Z</published>
    <updated>2019-11-13T06:32:19.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"><br>初学MCU的人，经常会看到ROM, RAM, FLASH，而且会被这些词汇搞得晕头转向。本文对这些概念进行了厘清，并介绍了这些Memory的区别</p><p><strong>备注</strong>：MCU-单片机，微型计算机</p><a id="more"></a><h2 id="ROM-Read-Only-Memory-程序存储器"><a href="#ROM-Read-Only-Memory-程序存储器" class="headerlink" title="ROM (Read Only Memory)程序存储器"></a>ROM (Read Only Memory)程序存储器</h2><p>它是一种只能读出事先所存的数据的固态半导体存储器。ROM中所存数据稳定，一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失。其结构简单，因而常用于存储各种固化程序和数据。</p><h2 id="RAM-Random-Access-Memory-随机访问存储器"><a href="#RAM-Random-Access-Memory-随机访问存储器" class="headerlink" title="RAM (Random Access Memory)随机访问存储器"></a>RAM (Random Access Memory)随机访问存储器</h2><p>RAM又称随机存取存储器，存储单元的内容可按照需要随机取出或存入，且存取的速度与存储单元的位置无关。这种存储器在断电时，将丢失其存储内容，所以主要用于存储短时间使用的程序。</p><p>它主要用来存储程序中用到的变量。凡是整个程序中，所用到的需要被改写的量（包括全局变量、局部变量、堆栈段等），都存储在RAM中。</p><h2 id="ROM-amp-RAM区别"><a href="#ROM-amp-RAM区别" class="headerlink" title="ROM&amp;RAM区别"></a>ROM&amp;RAM区别</h2><p><a href="https://blog.csdn.net/szupjz/article/details/51842242" target="_blank" rel="noopener">参考</a></p><p>通俗的说，比如在电脑中，大家都知道有内存和硬盘之说，其实内存就是一种RAM技术，而ROM则类似于硬盘技术，两者都是存储器，只是RAM的速度要远远高于ROM的速度。</p><p>在电脑日常操作中，很多程序都将临时运行的程序命令，存放在内存中，但一旦关机或者停电，内存里原本临时存储的程序信息将全部被清空，也就是内存只能临时存储东西，不能长久保存，而ROM则可以存储，即使掉电后也可以找到之前存储的文件，这也就是硬盘了。</p><h2 id="FLASH-存储器"><a href="#FLASH-存储器" class="headerlink" title="FLASH 存储器"></a>FLASH 存储器</h2><p>Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据。它于EEPROM的最大区别是，FLASH按扇区（block）操作，而EEPROM按照字节操作。FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因此适合用于做程序存储器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;br&gt;初学MCU的人，经常会看到ROM, RAM, FLASH，而且会被这些词汇搞得晕头转向。本文对这些概念进行了厘清，并介绍了这些Memory的区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：MCU-单片机，微型计算机&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://yoursite.com/2019/11/11/sentos%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2019/11/11/sentos相关/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-19T13:15:37.525Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>查看位数：getconf LONG_BIT<br>查看版本：cat /etc/redhat-release</p><h2 id="rpm和yum的关系以及基本用法"><a href="#rpm和yum的关系以及基本用法" class="headerlink" title="rpm和yum的关系以及基本用法"></a>rpm和yum的关系以及基本用法</h2><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h3><p>RPM是RedHat Package Manager（RedHat软件包管理工具）类似Windows里面的“添加/删除程序”<br>rpm 执行安装包<br>二进制包（Binary）以及源代码包（Source）两种。二进制包可以直接安装在计算机中，而源代码包将会由RPM自动编译、安装。源代码包经常以src.rpm作为后缀名。</p><h4 id="解压-rpm-包"><a href="#解压-rpm-包" class="headerlink" title="解压 rpm 包"></a>解压 rpm 包</h4><p>RPM包括是使用cpio格式打包的，因此可以先转成cpio然后解压，如下所示：<br>rpm2cpio xxx.rpm | cpio -div<br>解压后 里面会有 .spec 文件，是该包的描述文件</p><h3 id="Yum"><a href="#Yum" class="headerlink" title="Yum"></a>Yum</h3><p>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理 依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p><p>yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断。</p><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul><li>源码安装<br>源码的安装一般由3个步骤组成：配置(configure)、编译(make)、安装(make install)。</li></ul><pre><code>$ tar zxvf XXXX.tar.gz (or tar jxvf XXXX.tar.bz2)$ cd XXXX$ ./configure$ make$ make install</code></pre><p>清理安装后的临时文件：</p><blockquote><p>$ make clean</p></blockquote><p>卸载软件</p><blockquote><p>make uninstall</p></blockquote><h4 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h4><p>1、 下载源码包<br>2、 解压包<br>3、 设置软件的安装目录：$ ./configure –prefix=/opt/XXX<br>检查configure返回结果，为0代表运行成功：</p><blockquote><p>$ echo $?<br>0</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kancloud.cn/chandler/bc-linux/55602" target="_blank" rel="noopener">linux笔记</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-rpm/index.html" target="_blank" rel="noopener">RPM 打包技术与典型 SPEC 文件分析</a><br><a href="https://blog.csdn.net/huangfei711/article/details/53044539" target="_blank" rel="noopener">添加环境变量</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://yoursite.com/2019/11/11/%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/11/11/理解高性能网络模型/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-15T08:27:15.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="SQL优化" scheme="http://yoursite.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>bash学习</title>
    <link href="http://yoursite.com/2019/11/11/bash%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/11/bash学习/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-26T02:29:37.273Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="profile、bashrc、bash-profile之间的区别和联系"><a href="#profile、bashrc、bash-profile之间的区别和联系" class="headerlink" title="profile、bashrc、bash_profile之间的区别和联系"></a>profile、bashrc、bash_profile之间的区别和联系</h2><ul><li><strong>/etc/profile</strong></li></ul><p>系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行并从/etc/profile.d目录的配置文件中搜集shell的设置.<br>所以如果你有对/etc/profile有修改的话必须得重启你的修改才会生效，此修改对每个用户都生效。</p><ul><li><strong>/etc/bashrc</strong></li></ul><p>为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.<br>如果你想对所有的使用bash的用户修改某个配置并在以后打开的bash都生效的话可以修改这个文件，修改这个文件不用重启，重新打开一个bash即可生效。</p><ul><li><strong>~/.bash_profile</strong></li></ul><p>每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p><p>此文件类似于/etc/profile，也是需要需要重启才会生效，/etc/profile对所有用户生效，~/.bash_profile只对当前用户生效。</p><ul><li><strong>~/.bashrc</strong></li></ul><p>该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）</p><p>此文件类似于/etc/bashrc，不需要重启生效，重新打开一个bash即可生效，  /etc/bashrc对所有用户新打开的bash都生效，但~/.bashrc只对当前用户新打开的bash生效。</p><ul><li><strong>~/.bash_logout</strong></li></ul><p>当每次退出系统(退出bash shell)时,执行该文件. </p><p>另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是”父子”关系.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>~/.bash_profile 是交互式、login 方式进入bash 运行的；<br>~/.bashrc 是交互式 non-login 方式进入bash 运行的；<br>通常二者设置大致相同，所以通常前者会调用后者。</p><p><strong>执行顺序</strong>为：/etc/profile -&gt; (~/.bash_profile | ~/.bash_login | ~/.profile) -&gt; ~/.bashrc -&gt; /etc/bashrc -&gt; ~/.bash_logout</p><h2 id="SHELL的交互式和非交互式、登录和非登录的区别"><a href="#SHELL的交互式和非交互式、登录和非登录的区别" class="headerlink" title="SHELL的交互式和非交互式、登录和非登录的区别"></a>SHELL的交互式和非交互式、登录和非登录的区别</h2><p>交互式shell和非交互式shell、登录shell和非登录shell的区别。<br>首先，这是两个不同的维度来划分的，一个是是否交互式，另一个是是否登录。</p><h3 id="交互式和非交互式"><a href="#交互式和非交互式" class="headerlink" title="交互式和非交互式"></a>交互式和非交互式</h3><ul><li>交互式</li></ul><p>交互式模式就是在终端上执行，shell等待你的输入，并且立即执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、退出。当你退出后，shell也终止了。</p><ul><li>非交互式</li></ul><p>以shell script(非交互)方式执行。在这种模式 下，shell不与你进行交互，而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾EOF，shell也就终止了。</p><p>1.3 测试逻辑表达式<br>基本格式<br>-a : 逻辑与,操作符两边均为真,结果为真,否则为假。<br>-o : 逻辑或,操作符两边一边为真,结果为真,否则为假。<br>! : 逻辑否,条件为假,结果为真。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="bash" scheme="http://yoursite.com/categories/bash/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="http://yoursite.com/2019/11/11/SQL%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/11/SQL优化/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-13T11:07:46.517Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="连接查询-联合查询-子查询"><a href="#连接查询-联合查询-子查询" class="headerlink" title="连接查询 联合查询 子查询"></a>连接查询 联合查询 子查询</h2><ul><li>连接查询</li></ul><p>连接查询就是将多个表联合起来查询，连接查询方式有内连接、外连接、自然连接、交叉连接。连接查询使得可以同时查看多张表中数据。</p><pre><code>- 内连接：有条件连接，多个表之间依据指定条件连接，匹配结果是保留符合匹配结果的记录。- 外连接：与内连接不同的是不管匹配符不符合都保留，根据外连接连接方式来决定保留哪张表，比如保留左表的话，那么左表无法匹配右表时，保留左表数据，然后置右表字段数据为null.- 自然连接：有条件连接，自动依据“同名字段”连接（多个同名字段就都作为条件）。- 交叉连接cross join：无条件连接，将每一条记录与另外一个表的每一条记录连接（笛卡尔积），结果是字段数等于原来字段数之和，记录数等于之前各个表记录数之乘积。</code></pre><p>补充：在多个表中，为了区分每个表，以及简便使用，可以使用表别名。</p><ul><li>联合查询</li></ul><p>联合查询是将多个查询结果在记录上进行拼接。（相当于将其他表的查询记录结果连接到第一个表的后面）【因为是拼接，所以<strong>多个查询结果的字段数必须相同</strong>】【拼接不在意数据类型，比如第一个表的第一个字段是int,但后面的表中的varchar依然可以拼接到第一列中】</p><p>语法：select语句 union select语句…;</p><p>补充：union可以有选项，加在union 后面，all选项是不对相同去重，distinct是去重。</p><ul><li>子查询</li></ul><p>子查询是嵌套在查询语句中的查询。<br>可以分为三类：</p><p>from子查询：子查询跟在from之后的；一般用在“先查出二维表，再处理”的情况。<br>如：select cid,cname from (select * from class where cname=”python”) as c;</p><p>where子查询：子查询跟在where条件中；一般用在“先查询出指定条件再查询”的情况<br>如：select * from student where cid=(select cid from class where cname=”python”);</p><p>exist子查询：子查询在exist语句里面；一般用作“存在才做”的情况<br>如：select * from class where exists(select * from  student where cid=1) and cid=1;</p><h2 id="explain-优化神器"><a href="#explain-优化神器" class="headerlink" title="explain 优化神器"></a>explain 优化神器</h2><p><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">参考</a></p><h3 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h3><pre><code>mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: user_info   partitions: NULL         type: constpossible_keys: PRIMARY          key: PRIMARY      key_len: 8          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)</code></pre><p>各列的含义如下:</p><ul><li><strong>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</strong></li><li><strong>select_type: SELECT 查询的类型.</strong></li><li><strong>table: 查询涉及的表或衍生表</strong></li><li><strong>partitions: 匹配的分区</strong></li><li><strong>type: join 类型</strong></li><li><strong>possible_keys: 此次查询中可能选用的索引</strong></li><li><strong>key: 此次查询中确切使用到的索引.</strong></li><li><strong>ref: 哪个字段或常数与 key 一起被使用</strong></li><li><strong>key_len：表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</strong></li><li><strong>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.直观显示 SQL 的效率好坏, 原则上 rows 越少越好</strong></li><li><strong>filtered: 表示此查询条件所过滤的数据的百分比</strong></li><li><strong>extra: 额外的信息</strong></li></ul><p>下面是几个重要字段</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.</p><p>常见取值：</p><ul><li><strong>const:</strong> 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可</li><li><strong>eq_ref:</strong> 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. </li><li><strong>ref:</strong> 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li><li><strong>range:</strong> 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</li><li><strong>index:</strong> 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.</li><li><strong>ALL:</strong> 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</li></ul><p>通常来说, 不同的 type 类型的<strong>性能关系</strong>如下:</p><blockquote><blockquote><blockquote><p>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</p></blockquote></blockquote></blockquote><h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li>Using filesort</li></ul><p>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p><ul><li>Using index</li></ul><p>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p><ul><li>Using temporary</li></ul><p>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="SQL优化" scheme="http://yoursite.com/tags/SQL%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>bash学习</title>
    <link href="http://yoursite.com/2019/11/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/11/数据结构与算法/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-26T06:29:00.786Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p><a href="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126033120%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%E5%9B%BE.jpg" target="_blank" rel="noopener">总览图</a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ol><li>数据结构是指一组数据的存储结构</li><li>算法就是操作数据的方法</li><li>数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法要作用在特定的数据结构之上</li></ol><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。<br>从狭义上讲，指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。<br>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p><ol><li>数据结构和算法学习的精髓-复杂度分析</li><li>最常用的、最基础的数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</li><li>最常用的算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法<h2 id="为什么学"><a href="#为什么学" class="headerlink" title="为什么学"></a>为什么学</h2></li><li>直接好处是能够有写出性能更优的代码。</li><li>算法，是一种解决问题的思路和方法，有机会应用到生活和事业的其他方面。</li><li>长期来看，大脑思考能力是个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。</li></ol><h2 id="如何学"><a href="#如何学" class="headerlink" title="如何学"></a>如何学</h2><ol><li>一定要动手写</li><li>千万不要被动地记忆，要多辩证地思考，多问为什么。</li><li>边学边练，适度刷题</li><li>知识需要沉淀，不要想试图一下子掌握所有</li><li>结合实际：排个队想到队列，火车进站想到堆栈，看到树上开花想到树的某些指标，导航想到贪心，将生活场景与算法和数据结构的场景结合起来。</li></ol><h3 id="重点学习"><a href="#重点学习" class="headerlink" title="重点学习"></a>重点学习</h3><p>20 个最常用的、最基础数据结构与算法，不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。<br>这里面有 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；<br>10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p><p><strong>复杂度分析</strong>是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>时间复杂度又称<strong>渐进时间复杂度</strong>：表示算法的执行时间与数据规模之间的增长关系</p><p>空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的<strong>存储空间与数据规模</strong>之间的增长关系。</p><h3 id="时间复杂度（重中之中）"><a href="#时间复杂度（重中之中）" class="headerlink" title="时间复杂度（重中之中）"></a>时间复杂度（重中之中）</h3><p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的<strong>变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称时间复杂度。</p><p>PS：即使一段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。</p><p>尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度<br>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积<br>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n)).</li></ol><h4 id="常见的复杂度量级"><a href="#常见的复杂度量级" class="headerlink" title="常见的复杂度量级"></a>常见的复杂度量级</h4><p><img src="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126035226%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg" alt="常见的复杂度量级"><br>我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p><p>主要来看几种常见的多项式时间复杂度。</p><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p><p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><h5 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h5><pre><code>i=1;while (i &lt;= n)  {    i = i * 2;  可为2 3 4 时间复杂度就是 O(log2n) O(log3n)}</code></pre><p>对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C *  log2n)，其中 C=log32 是一个常量。</p><p>基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。</p><p>因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><h5 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h5><p>代码的复杂度由两个数据的规模来决定,从代码中可以看出，m 和 n 是表示两个数据规模。</p><p>我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>全称就是渐进空间复杂度（asymptotic space complexity），表示算法的<strong>存储空间与数据规模</strong>之间的增长关系。</p><pre><code>void print(int n) {  int i = 0;  int[] a = new int[n];  for (i; i &lt;n; ++i) {    a[i] = i * i;  }  for (i = n-1; i &gt;= 0; --i) {    print out a[i]  }}</code></pre><p>第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。</p><p>第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><p>空间复杂度就是 O(1)、O(n)、O(n2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p><h3 id="复杂度分类"><a href="#复杂度分类" class="headerlink" title="复杂度分类"></a>复杂度分类</h3><p>四个复杂度分析方面的知识点</p><ul><li>最好情况时间复杂度（best case time complexity）</li><li>最坏情况时间复杂度（worst case time complexity）</li><li>平均情况时间复杂度（average case time complexity）</li><li>均摊时间复杂度（amortized time complexity）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，</p><p>越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。</p><p><img src="https://images.cnblogs.com/cnblogs_com/luoyangyang/1573981/t_191126062213%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90.jpg" alt="复杂度分析"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="bash" scheme="http://yoursite.com/categories/bash/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题</title>
    <link href="http://yoursite.com/2019/11/11/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/11/MySQL常见问题/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-26T07:50:25.609Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="innodb-自增主键不连续"><a href="#innodb-自增主键不连续" class="headerlink" title="innodb 自增主键不连续"></a>innodb 自增主键不连续</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>参数innodb_autoinc_lock_mode = 1时，每次会“预申请”多余的id(handler.cc:compute_next_insert_id)，而insert执行完成后，会特别将这些预留的id空出，就是特意将预申请后的当前最大id回写到表中</p><p>所以导致ID不连续的原因是因为innodb_autoinc_lock_mode = 1时，会多申请id。好处是：一次性分配足够的auto_increment id，只会将整个分配的过程锁住。</p><h2 id="为什么大多数生产环境不用外键"><a href="#为什么大多数生产环境不用外键" class="headerlink" title="为什么大多数生产环境不用外键"></a>为什么大多数生产环境不用外键</h2><p>其实这个话题是老生常谈，很多人在工作中确实也不会使用外键。包括在阿里的JAVA规范中也有下面这一条</p><ul><li>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</li></ul><p>但是呢，询问他们原因，大多是这么回答的</p><ul><li>每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便。</li></ul><ol><li>性能损耗</li><li>迁移数据时候的一致性维护</li></ol><p>这么说也是对的。下面详细说明</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先我们明确一点，外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”。因此，外键约束的存在，并非全然没有优点。<br>比如使用外键，可以</p><ul><li>保证数据的完整性和一致性</li><li>级联操作方便</li><li>将数据完整性判断托付给了数据库完成，减少了程序的代码量</li></ul><p>然而，鱼和熊掌不可兼得。外键是能够保证数据的完整性，但是会给系统带来很多缺陷。正是因为这些缺陷，才导致我们不推荐使用外键，具体如下：</p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。</p><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。</p><h4 id="扩展性问题"><a href="#扩展性问题" class="headerlink" title="扩展性问题"></a>扩展性问题</h4><p>这里主要是分为两点</p><p>做平台迁移方便，比如你从Mysql迁移到Oracle，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。<br>分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。<br>技术问题<br>使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，那么这就对DBA的要求就更高了。很多中小型公司由于资金问题，并没有聘用专业的DBA，因此他们会选择不用外键，降低数据库的消耗。<br>相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。</p><h2 id="为什么一定要设一个主键？"><a href="#为什么一定要设一个主键？" class="headerlink" title="为什么一定要设一个主键？"></a>为什么一定要设一个主键？</h2><p><strong>回答：</strong> 因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。所以啦，反正都要生成一个主键，那你还不如自己指定一个主键，在有些情况下，就能显式的用上主键索引，提高查询效率！</p><h2 id="主键是用自增还是UUID"><a href="#主键是用自增还是UUID" class="headerlink" title="主键是用自增还是UUID?"></a>主键是用自增还是UUID?</h2><p><strong>回答：</strong> 肯定答自增啊。innodb 中的主键是聚簇索引。如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果不是自增主键，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片！  <strong>简单说用自增插入性能好！</strong></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>UUID缺点： </p><ol><li>影响插入速度， 并且造成硬盘使用率低</li><li>uuid之间比较大小相对于自增id比较大小要慢很多， 影响查询速度。</li><li>uuid占空间大， 如果你建的索引越多， 影响越严重</li></ol><p>UUID优点：出现数据拆分、合并存储的时候，能达到全局的唯一性（比如：历史数据表的主键id会与数据表的id重复，两张自增id做主键的表合并时，id一定会有冲突，但如果各自的id还关联了其他表，这就很不好操作。而使用UUID，生成的ID不仅是表独立的，而且是库独立的。）</p><ul><li>在分布式环境下可使用UUID，自增合并表时会发生id重复的问题，但也可设置自增的间隔</li></ul><h5 id="自增ID用完怎么办？"><a href="#自增ID用完怎么办？" class="headerlink" title="自增ID用完怎么办？"></a>自增ID用完怎么办？</h5><p><strong>回答：</strong> 戳 =&gt; <a href="https://www.cnblogs.com/rjzheng/p/10669043.html" target="_blank" rel="noopener">this</a></p><h2 id="主键为什么不推荐有业务含义"><a href="#主键为什么不推荐有业务含义" class="headerlink" title="主键为什么不推荐有业务含义?"></a>主键为什么不推荐有业务含义?</h2><p><strong>回答：</strong> 有如下两个原因</p><p>(1)因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。</p><p>(2)带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</p><h2 id="表示枚举的字段为什么不用enum类型？"><a href="#表示枚举的字段为什么不用enum类型？" class="headerlink" title="表示枚举的字段为什么不用enum类型？"></a>表示枚举的字段为什么不用enum类型？</h2><p><strong>回答：</strong> 在工作中表示枚举的字段，一般用tinyint类型。<br>那为什么不用enum类型呢？下面两个原因</p><p>(1)ENUM类型的ORDER BY操作效率低，需要额外操作<br>(2)如果枚举值是数值，有陷阱</p><h2 id="货币字段用什么类型"><a href="#货币字段用什么类型" class="headerlink" title="货币字段用什么类型?"></a>货币字段用什么类型?</h2><p><strong>回答：</strong> 如果货币单位是分，可以用Int类型。如果坚持用元，用Decimal。<br>千万不要答float和double，因为float和double是以二进制存储的，所以有一定的误差。</p><h2 id="时间字段用什么类型"><a href="#时间字段用什么类型" class="headerlink" title="时间字段用什么类型?"></a>时间字段用什么类型?</h2><p><strong>回答：</strong> 此题无固定答案，应结合自己项目背景来答！把理由讲清楚就行！</p><p>(1)varchar，如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为2013111的数据，请问这是代表2013年1月11日，还是2013年11月1日？<br>其次，做时间比较运算，你需要用STR_TO_DATE等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！</p><p>(2)timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。<br>但是它有一个优势，timestamp类型是带有时区信息的。一旦你系统中的时区发生改变，例如你修改了时区</p><p>SET TIME_ZONE = “america/new_york”;<br>你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时，特别注意！</p><p>(3)datetime，datetime储存占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，他存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！</p><p>(4)bigint，也是8个字节，自己维护一个时间戳，表示范围比timestamp大多了，就是要自己维护，不大方便。</p><h2 id="为什么不直接存储图片、音频、视频等大容量内容"><a href="#为什么不直接存储图片、音频、视频等大容量内容" class="headerlink" title="为什么不直接存储图片、音频、视频等大容量内容?"></a>为什么不直接存储图片、音频、视频等大容量内容?</h2><p><strong>回答：</strong> 我们在实际应用中，都是用HDFS来存储文件。然后mysql中，只存文件的存放路径。mysql中有两个字段类型被用来设计存放大容量文件，也就是text和blob类型。但是，我们在生产中，基本不用这两个类型！<br>主要原因有如下两点</p><p>(1)Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。导致查询效率缓慢<br>(2)binlog内容太多。因为你数据内容比较大，就会造成binlog内容比较多。大家也知道，主从同步是靠binlog进行同步，binlog太大了，就会导致主从同步效率问题！<br>因此，不推荐使用text和blob类型！</p><h2 id="字段为什么要定义为NOT-NULL"><a href="#字段为什么要定义为NOT-NULL" class="headerlink" title="字段为什么要定义为NOT NULL?"></a>字段为什么要定义为NOT NULL?</h2><p><strong>回答：</strong><br>(1)索引性能不好<br>Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。<br>—— 出自《高性能mysql第二版》</p><p>(2)查询会出现一些不可预料的结果<br>这里举一个例子，大家就懂了。假设，表结构如下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>堆栈详解</title>
    <link href="http://yoursite.com/2019/11/11/%E5%A0%86%E6%A0%88%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/11/堆栈详解/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-22T01:21:42.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="简介堆栈"><a href="#简介堆栈" class="headerlink" title="简介堆栈"></a>简介堆栈</h2><p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。</p><p><strong>代码区</strong>：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。</p><p><strong>静态数据区</strong>：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。</p><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p><h3 id="内存中的堆栈"><a href="#内存中的堆栈" class="headerlink" title="内存中的堆栈"></a>内存中的堆栈</h3><h4 id="堆栈空间分配"><a href="#堆栈空间分配" class="headerlink" title="堆栈空间分配"></a>堆栈空间分配</h4><p><strong>栈</strong>（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p><strong>堆</strong>（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p><h4 id="堆栈缓存方式"><a href="#堆栈缓存方式" class="headerlink" title="堆栈缓存方式"></a>堆栈缓存方式</h4><p>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</p><p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p><p>以上概念如下所示：</p><pre><code>//main.cppint a = 0; //全局初始化区int a = 0; //全局初始化区char *p1; //全局未初始化区main() {    int b; //栈    char s[] = &quot;abc&quot;; //栈    char *p2; //栈    char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上。    static int c = 0; //全局（静态）初始化区    p1 = (char *)malloc(10);    p2 = (char *)malloc(20);    //分配得来得10和20字节的区域就在堆区。    strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。}</code></pre><h3 id="数据结构中的堆栈"><a href="#数据结构中的堆栈" class="headerlink" title="数据结构中的堆栈"></a>数据结构中的堆栈</h3><p>栈：是一种连续存储的数据结构，特点是存储的数据先进后出。</p><p>堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。</p><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈  stack"></a>栈  stack</h2><p><a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="noopener">参考</a><br>这个词其实有三种含义，适用于不同的场合</p><h3 id="1、-数据结构"><a href="#1、-数据结构" class="headerlink" title="1、 数据结构"></a>1、 数据结构</h3><p>stack的第一种含义是一组数据的存放方式，特点为LIFO，即后进先出（Last in, first out）。<br>在这种数据结构中，数据像积木那样一层层堆起来，后面加入的数据就放在最上层。使用的时候，最上层的数据第一个被用掉，这就叫做”后进先出”。</p><p>与这种结构配套的，是一些特定的方法，主要为下面这些。</p><ul><li>push：在最顶层加入数据。</li><li>pop：返回并移除最顶层的数据。</li><li>top：返回最顶层数据的值，但不移除它。</li><li>isempty：返回一个布尔值，表示当前stack是否为空栈。</li></ul><h3 id="2、-代码运行方式"><a href="#2、-代码运行方式" class="headerlink" title="2、 代码运行方式"></a>2、 代码运行方式</h3><p>stack的第二种含义是”调用栈”（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。</p><p>程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果。</p><h3 id="3、-内存区域"><a href="#3、-内存区域" class="headerlink" title="3、 内存区域"></a>3、 内存区域</h3><p>stack的第三种含义是存放数据的一种内存区域。程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做stack（栈），另一种叫做heap（堆）。</p><p>它们的主要区别是：stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap是没有结构的，数据可以任意存放。因此，stack的寻址速度要快于heap。</p><p>其他的区别还有，一般来说，<strong>每个线程分配一个stack，每个进程分配一个heap</strong>，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。</p><p>根据上面这些区别，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面。请看下面这段代码（来源）。</p><h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><p><a href="https://blog.csdn.net/pt666/article/details/70876410" target="_blank" rel="noopener">参考</a></p><ol><li>栈内存存储的是局部变量而堆内存存储的是实体；</li><li>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</li><li>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</li><li>管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</li><li>空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</li><li>生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</li><li>分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>小知识总结</title>
    <link href="http://yoursite.com/2019/11/11/%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/11/小知识总结/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-25T12:46:56.270Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><p>PNG 比 JPEG 格式质量好，占空间，同一张图片 PNG 26M，JPEG 为 4 M<br>可移植性就是可以在多个系统运使用行<br>request 请求接口时，发起一个带证书的请求，用法如下所示：</p><pre><code>let opt = {        url:&quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&quot;,        body:sendData,        key: fs.readFileSync(&#39;./config/apiclient_key.pem&#39;), // 将微信生成的证书放入 cert目录下        cert: fs.readFileSync(&#39;./config/apiclient_cert.pem&#39;),        // ca:fs.readFileSync(&#39;./config/apiclient_cert.p12&#39;)    }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小知识" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>学习重点</title>
    <link href="http://yoursite.com/2019/11/11/%E5%AD%A6%E4%B9%A0%E9%87%8D%E7%82%B9/"/>
    <id>http://yoursite.com/2019/11/11/学习重点/</id>
    <published>2019-11-11T09:25:25.000Z</published>
    <updated>2019-11-20T10:15:04.948Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png" alt="mysql"></p><a id="more"></a><h2 id="重点学习"><a href="#重点学习" class="headerlink" title="重点学习"></a>重点学习</h2><p><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">计算机编程类中文书籍</a><br><a href="http://cn.linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜2</a></p><h2 id="正在学习"><a href="#正在学习" class="headerlink" title="正在学习"></a>正在学习</h2><p><a href="https://blog.csdn.net/hguisu/article/details/6122513" target="_blank" rel="noopener">Linux系统结构详解</a></p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.kancloud.cn/chandler/bc-linux/167673" target="_blank" rel="noopener">Linux笔记</a><br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html#" target="_blank" rel="noopener">Linux工具快速教程</a><br><a href="https://www.zhihu.com/question/23834032/answer/695582133" target="_blank" rel="noopener">Linux</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU3NTgyODQ1Nw==&mid=100001442&idx=1&sn=a55159ef053b3de9981392dfa3fbdc55&chksm=7d1c7e244a6bf732b3db64e1c6a8faadfc7b70220ab83594ffbec2c0b45de98876290bd15956&mpshare=1&scene=1&srcid=&sharer_sharetime=1574219162639&sharer_shareid=b10a18feaf6602ba28d0ac434169dfed#rd" target="_blank" rel="noopener">良许Linux</a></p><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ul><li>操作系统<br><a href="https://linux.vbird.org/linux_basic/centos7/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a><br>深入理解计算机系统（第三版）<br>unix网络编程(比较难，后期看)<br>Linux从入门到精通<br>Linux命令行大全<br>Linux就该这么学</li></ul><ul><li>MySQL</li></ul><p>MySQL必知必会<br>深入浅出MySQL(尤其是将)</p><ul><li>Python</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.youhutong.com/static/appImage/article/thumb/8e43ba8c3810921daff968b4105fbfa5.png&quot; alt=&quot;mysql&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>消息队列&amp;CMQ</title>
    <link href="http://yoursite.com/2019/11/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&amp;CMQ/"/>
    <id>http://yoursite.com/2019/11/05/消息队列&amp;CMQ/</id>
    <published>2019-11-05T07:25:25.000Z</published>
    <updated>2019-11-14T02:03:41.695Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png" alt="hh"></p><a id="more"></a><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>QPS</strong>： Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p><strong>TPS</strong>： 是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p><strong>吞吐量</strong>： 一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。</p><p>是指在一次性能测试过程中网络上传输的数据量的总和。但一般指指系统在单位时间内处理请求的数量</p><p><strong>吞吐率</strong>: 特指Web服务器单位时间内处理的请求数。</p><p>系统吞吐量几个重要参数：</p><ul><li>QPS（TPS）：每秒钟request/事务 数量</li><li>并发数： 系统同时处理的request/事务数</li><li>响应时间：  一般取平均响应时间</li></ul><p>理解了上面三个要素的意义之后，就能推算出它们之间的关系：<br>QPS（TPS）= 并发数/平均响应时间    或者   并发数 = QPS*平均响应时间</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。</p><p>同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。</p><p>CMQ/CKafka/MQ for IoT本质上都属于分布式消息中间件，分布式消息系统的最大特点是可扩展性。核心理念是多个节点协同工作完成单个节点无法完成的任务，不允许出现单节点故障服务不可用（RTO）和数据丢失（RPO）情况。归根结底是解决CAP问题, CMQ作为金融级别服务要求数据高可靠强一致（CP）, CKafka以大数据领域为主要服务对象，更偏重于AP,同时允许用户通过配置在CAP之间进行权衡</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>服务解耦</strong>： 多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；</li><li><strong>异步处理</strong>： 多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间。如用户注册后，需要发送注册邮件和发送注册信息，传统的做法有两种：串行方式、并行方式</li><li><strong>削峰限流</strong>： 广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li><li><strong>广播订阅</strong>： 发送方不关心谁订阅这个消息，只管发出来，拓展方便；</li><li>流式数据过滤： 消费者通过类似SQL语句来筛选自己感兴趣的数据；</li><li>两阶段消息： 通过两阶段消息与本地数据库事务相结合达到简单分布式事务。</li></ul><h3 id="两种消息模型"><a href="#两种消息模型" class="headerlink" title="两种消息模型"></a>两种消息模型</h3><h4 id="P2P（Point-to-Point）"><a href="#P2P（Point-to-Point）" class="headerlink" title="P2P（Point to Point）"></a>P2P（Point to Point）</h4><p>P2P模式包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><p>P2P的特点：</p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><h4 id="Publish-Subscribe-Pub-Sub"><a href="#Publish-Subscribe-Pub-Sub" class="headerlink" title="Publish/Subscribe(Pub/Sub)"></a>Publish/Subscribe(Pub/Sub)</h4><p>包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p><p>Pub/Sub的特点:</p><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li><li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li><li>如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。</li></ul><h2 id="CMQ"><a href="#CMQ" class="headerlink" title="CMQ"></a>CMQ</h2><p>消息队列 CMQ 支持 Pull（队列） 和 Push（主题） 两种方式：</p><ul><li>Push 模型：当 Producer 发出的消息到达后，服务端马上将这条消息投递给 Consumer。</li><li>Pull 模型：当服务端收到这条消息后什么也不做，只是等着 Consumer 主动到自己这里来读，即 Consumer 这里有一个“拉取”的动作。<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://ruby-china.org/topics/26221" target="_blank" rel="noopener">吞吐量、QPS、TPS</a><br><a href="https://www.jianshu.com/p/689ce4205021" target="_blank" rel="noopener">消息队列简介</a><br><a href="https://cloud.tencent.com/document/api/406/5851" target="_blank" rel="noopener">CMQ API</a><br><a href="https://cloud.tencent.com/document/product/406" target="_blank" rel="noopener">CMQ 文档中心</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png&quot; alt=&quot;hh&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="CMQ" scheme="http://yoursite.com/tags/CMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统基础知识</title>
    <link href="http://yoursite.com/2019/11/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/11/05/计算机系统基础知识/</id>
    <published>2019-11-05T07:25:25.000Z</published>
    <updated>2019-11-21T03:49:29.610Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png" alt="hh"></p><a id="more"></a><h2 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h2><ul><li>位：即 bit，表示二进制位，要么是 0 ，要么是 1。它是计算机内部数据存储的最小单位。比如 11010100 共有8个二进制位，是一个8位二进制数。</li><li>字节：即 byte，它由8个二进制位构成，即 1byte=8bit，是计算机内部计量的基本单位。一个英文字符占1个字节（8位），一个汉字占2个字节（16位）</li><li>字：即word，它由若干个字节构成，是计算机内部进行数据处理和运算的基本单位。字的总的位数称为字长，不同档次的计算机字长是不一样的，比如32位机，它的1个字由4个字节构成，字长为32位，也就是说其CPU一次操作处理的实际位数是32位。同理，64位机可以处理64位。由此可见，计算机的字长越大，其性能越优越。</li><li>KB，MB：1024byte = 1KB，1024KB = 1MB。往上还有GB，TB。</li></ul><p>PS：数据传输大多以 bit 为单位，比如我们常说的网速100M/s，M/s其实Mbit/s，也就是兆比特每秒，我们还可以写成100Mbps。<br>    实际上对于档案大小来说为100M/8 每秒的速度</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><h3 id="为什么需要字符编码？"><a href="#为什么需要字符编码？" class="headerlink" title="为什么需要字符编码？"></a>为什么需要字符编码？</h3><ul><li>计算机只能理解0和1，无法理解英文、字母、汉字和其他特殊字符，这些字符需要经过编码才能成为计算机可以理解的二进制数。</li><li>由字符到二进制数称为编码，反过来则是解码。</li><li>从字符到二进制数，需要有一个一一对应的映射，这个映射通过编码规则来实现。</li><li>通常所说的编码其实包括编码+字符集（即字符的集合体），比如 Unicode 字符集，就有 UTF-8，UTF-16 等多种编码。</li></ul><h3 id="utf-8-base64"><a href="#utf-8-base64" class="headerlink" title="utf-8 base64"></a>utf-8 base64</h3><ul><li><p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码。</p></li><li><p>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一</p></li></ul><p>base64的话，不是底层存储格式，只是为了数据交换用有。比如图片变成字符格式，这是一种应用格式</p><h3 id="编码规则的演变"><a href="#编码规则的演变" class="headerlink" title="编码规则的演变"></a>编码规则的演变</h3><ul><li><p>ASCII：</p><ol><li>/ˈæski/，即 American Standard Code for Information Interchange，美国信息交换标准代码。本来一个字节有8位，每一位有0和1两种状态，则一个字节共有2^8=256种状态，可以表示256种字符。但是美国佬比较自私，觉得只要可以表示自己的字母和一些特殊字符就足够了，所以 ASCII 没有占用最高位（而是固定为0），实际只用到了后面7位，它可以表示 2^7=128 种状态，也就是表示128个字符。</li><li>很显然，这用来表示字母是足够的，但要想表示其它语言的字符，128还是太少了。</li></ol></li><li><p>GB2312：</p><ol><li>既然美国佬只解决了字母和特殊符号的编码问题，那么我们中国人只好实现自己的编码，从而来表示汉字了。所以这时候出现了 GB2312 编码（国标码）。</li><li>问题：不幸的是，各个国家都是这么想的，所以小日本有了 Shift_JIS 编码，棒子有了 Euc-kr 编码…..一时之间各国都有了自己的标准，那么对于一个多语言混合的文本来说，存在着不同的编码规则，最终必然导致乱码。</li></ol></li><li><p>Unicode:</p><ol><li>Unicode 解决了编码统一的问题。每种语言的每个字符在 Unicode 的规则下，都只有统一且唯一的对应二进制编码。它的表示方法是U+[16进制数]。例如，大写字母 A 编码为 U+0041，汉字“严”编码为 U+4E25。</li><li>问题：Unicode 一般用2个字节（也就是16位）表示一个字符，这在表示 ASCII 字符的时候会出现问题。我们知道，ASCII 字符实际只需要一个字节就够了，并且最高位甚至都还不需要用到，但是 Unicode 又规定表示一个字符至少需要2个字节，那么一个 ASCII 字符前面就必须要补0以满足这个规则，例如字母 A 就需要用 00000000 01000001 表示，这些多余的0是一个极大的资源浪费。</li></ol></li><li><p>UTF-8：</p><ol><li>UTF：实际传输过程中，基于不同的系统平台，对 Unicode 会有不不同的实现方式，其实现方式称为 Unicode Transformation Format，即 UTF。</li><li>作为 Unicode 的一种实现方式，UTF-8 展现了一定的灵活性——它是一种变长编码，会根据具体字符来改变所需要的表示字节。其编码规则只有两条：</li></ol></li></ul><p>i&gt;. 对于 128 个 ASCII 字符只需一个字节表示，字节的第一位补 0，后面 7 位为这个字符的 ASCII 二进制数。Unicode 范围为 U+0000 至U+007F。<br>ii&gt;. 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码二进制数。Unicode 范围由 U+0080 起。</p><h2 id="原码、反码、补码知识详细讲解"><a href="#原码、反码、补码知识详细讲解" class="headerlink" title="原码、反码、补码知识详细讲解"></a>原码、反码、补码知识详细讲解</h2><p><a href="https://blog.csdn.net/zl10086111/article/details/80907428" target="_blank" rel="noopener">参考</a></p><h3 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h3><ul><li>机器数</li></ul><p>一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p><ul><li>真值</li></ul><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><h3 id="原码-反码-补码的基础概念和计算方法"><a href="#原码-反码-补码的基础概念和计算方法" class="headerlink" title="原码, 反码, 补码的基础概念和计算方法"></a>原码, 反码, 补码的基础概念和计算方法</h3><p>对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p><code>[+1]原 = 0000 0001</code><br><code>[-1]原 = 1000 0001</code></p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><p><code>[+1] = [00000001]原 = [00000001]反</code><br><code>[-1] = [10000001]原 = [11111110]反</code></p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>补码的表示方法是:</p><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补</code><br><code>[-1] = [10000001]原 = [11111110]反 = [11111111]补</code></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h3 id="异或（-）运算"><a href="#异或（-）运算" class="headerlink" title="异或（^）运算"></a>异或（^）运算</h3><p>异或运算通俗地讲就是一句话<br>同为假，异为真<br>所以它是这样的算法:</p><blockquote><p>0^0=0,0^1=1,1^0=1,1^1=0</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png&quot; alt=&quot;hh&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="计算机系统" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="编码" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>node学习</title>
    <link href="http://yoursite.com/2019/11/05/node%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/05/node学习/</id>
    <published>2019-11-05T07:25:25.000Z</published>
    <updated>2019-11-21T07:23:55.132Z</updated>
    
    <content type="html"><![CDATA[<p>关于面试的点点滴滴</p><a id="more"></a><p>a.getFullYear() + “-“ + (a.getMonth() &lt; 10 ? ‘0’ + (a.getMonth()+1) : (a.getMonth()+1)) + “-“ + (a.getDate() &lt; 10 ? ‘0’ + a.getDate() : a.getDate()) ;</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li><p>for 或者 foreach 进行循环获取数组值<br>var array = [‘a’, ‘b’, ‘c’, ‘d’];<br>for (var i = 0; i &lt; array.length; i++)<br>array.forEach(function (element)</p></li><li><p>for..in 遍历对象属性（或索引）<br>for (var key in array)</p></li></ul><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p><a href="https://blog.csdn.net/cvper/article/details/79543262" target="_blank" rel="noopener">查看包版本</a><br>假设现在我们已经成功下载了jquery，过了一段时间，我忘记了下载的jquery的版本信息</p><p>第一种方式：npm ls jquery 即可（查看本地安装的jQuery），下面我的本地没有安装jquery，<br>第二种方式：npm ls jquery -g    (查看全局安装的jquery)</p><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>参考：<br><a href="https://itbilu.com/nodejs/npm/VJHw6ScNb.html" target="_blank" rel="noopener">bluebird与原生Promise对象及bluebird模块的中文API文档</a><br><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">Promise迷你书</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>俩个特点：</p><ul><li>对象的状态不受外界影响，只有异步操作的结果可决定状态，pending（进行中）、fulfilled（已成功）和rejected（已失败）。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li></ul><p>在NodeJS中用于替代回调函数，在使用NodeJS的KOA框架时可使用Promise来代替回调函数。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="new-Promise-创建实例"><a href="#new-Promise-创建实例" class="headerlink" title="new Promise - 创建实例"></a>new Promise - 创建实例</h4><p>new Promise(function(function resolve, function reject) resolver) -&gt; Promise</p><h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async&amp;await"></a>async&amp;await</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>await:表示等待 Promise 返回结果，在继续执行。<br>async:由于nodejs是异步编程模型，有一些在同步编程中很容易做到的事情，现在却变得很麻烦。async的流程控制就是为了简化这些操作。</p><p>返回值是一个Promise对象，使用then方法添加回调函数<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br>async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p><ul><li>在函数体前通过关键字async可以将函数变为async函数</li><li>在async函数中对需要异步执行的函数前需加await关键字</li><li>await后的函数必须使用Promise对象封装</li><li>async函数执行后返回的是一个Promise对象</li></ul><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><h3 id="Node-js时间戳和日期互相转换"><a href="#Node-js时间戳和日期互相转换" class="headerlink" title="Node.js时间戳和日期互相转换"></a>Node.js时间戳和日期互相转换</h3><ul><li><p>日期转时间戳<br>var date = new Date(“2018-11-20 18:08:00”);<br>var time = date.getTime()/1000;//转换成秒；  getTime() =&gt; 转化为时间戳</p></li><li><p>时间戳转日期<br>var time = 1542708681;<br>// 也可以获取当前的毫秒级时间戳<br>var time2 = Date.now();<br>var date = new Date(time * 1000);<br>var dt = date.getFullYear() + “-“ + (date.getMonth() &lt; 10 ? ‘0’ + (date.getMonth()+1) : (date.getMonth()+1)) + “-“ + (date.getDate() &lt; 10 ? ‘0’ + date.getDate() : date.getDate()) ;</p></li></ul><h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><a href="https://www.jianshu.com/p/b240051784ab" target="_blank" rel="noopener">node-request模块</a></p><pre><code>request({    url: url,    type: &#39;post&#39;    encoding: &#39;utf-8&#39;,  // utf-8则 body为string，为null则为buffer，}, async function(error, response, body) {    resolve(body)})</code></pre><h3 id="xml2js-xml-json-相互转化"><a href="#xml2js-xml-json-相互转化" class="headerlink" title="xml2js - xml json 相互转化"></a>xml2js - xml json 相互转化</h3><p>安装：npm install xml2js</p><p>使用：</p><p>  var xml2js = require(‘xml2js’);</p><p>  var builder = new xml2js.Builder();  // JSON-&gt;xml<br>  var parser = new xml2js.Parser();   //xml -&gt; json</p><p>  var json =  parser.parseString（xml）;</p><p>  。。。。。</p><p>  xml =  builder.buildObject（json）;</p><h3 id="koa2"><a href="#koa2" class="headerlink" title="koa2"></a>koa2</h3><p>web框架。koa中间件，中间件的通过next函数联系,执行next()后会将控制权交给下一个中间件,如果没有中间件没有执行next后将会沿路折返,将控制权交换给前一个中间件。<br>ctx封装了request 和response对象<br>ctx.state  推荐的命名空间，用于通过中间件传递信息和你的前端视图</p><ul><li>get请求参数获取：</li></ul><p>1.是从上下文中直接获取<br>请求对象ctx.query，返回如 { a:1, b:2 }<br>请求字符串 ctx.querystring，返回如 a=1&amp;b=2<br>2.是从上下文的request对象中获取<br>请求对象ctx.request.query，返回如 { a:1, b:2 }<br>请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2</p><ul><li>POST请求参数获取：</li></ul><p>注意：ctx.request是context经过封装的请求对象，ctx.req是context提供的node.js原生HTTP请求对象，<br>同理ctx.response是context经过封装的响应对象，ctx.res是context提供的node.js原生HTTP请求对象。</p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>Buffer是node的核心模块，开发者可以利用它来处理二进制数据，比如文件流的读写、网络请求数据的处理等。</p><p>创建：<br>new Buffer(array)<br>Buffer.alloc(length)<br>Buffer.allocUnsafe(length)<br>Buffer.from(array)</p><h3 id="bluebird"><a href="#bluebird" class="headerlink" title="bluebird"></a>bluebird</h3><p>Bluebird 的 Promise.promisifyAll 方法可以为一个对象的属性中的所有方法创建一个对应的使用 Promise 的版本。这些新创建方法的名称在已有方法的名称后加上”Async”后缀。</p><ul><li>用法：<br>const bluebird = require(‘bluebird’)<br>bluebird.promisifyAll(fs)</li></ul><p>如果不希望把一个对象的所有方法都自动转换成使用 Promise 的形式，可以使用 Promise.promisify 来转换单个方法，如 Promise.promisify(require(“fs”).readFile)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于面试的点点滴滴&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>记录一次小程序开发</title>
    <link href="http://yoursite.com/2019/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/10/31/小程序项目记录/</id>
    <published>2019-10-31T07:25:25.000Z</published>
    <updated>2019-11-21T13:09:23.048Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次小程序开发，出现的坑以及一些知识</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>openID：不同APP不同openID。用户唯一标识，跟人一一对应，小程序分配给每个人的ID  OpenID = 用户微信号 &amp; 公众平台APPID（两个数据加密得到的字符串）  不同公众号不同ID</p></li><li><p>unionID：即使不同应用，ID一样。通过获取用户基本信息接口，开发者可通过OpenID来获取用户基本信息</p></li><li><p>appID(小程序ID):它其实就是小程序的「身份证号码」</p></li><li><p>AppSecret(小程序密钥)</p></li><li><p>PV：分享给了多少人</p></li><li><p>UV：分享的课程被多少人打开</p></li><li><p>openGid：小程序的群唯一标识的id</p></li></ul><h2 id="利用-puppeteer-可以生成一个网页的图片"><a href="#利用-puppeteer-可以生成一个网页的图片" class="headerlink" title="利用 puppeteer 可以生成一个网页的图片"></a>利用 puppeteer 可以生成一个网页的图片</h2><p><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" target="_blank" rel="noopener">参考文档</a></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><ul><li>node没有原生的取POST请求体<br>koa中可以利用 koa-body，如：router.post(‘/del_room’, <strong>koaBody()</strong>, async (ctx)</li></ul><p><strong>但是</strong>取xml koa-body不行，可以从原生的数据中读取<br>如：</p><pre><code>getPostData = function (ctx) {    return new Promise((resolve, reject) =&gt; {        var data = &quot;&quot;;        ctx.req.on(&quot;data&quot;, chunk =&gt; data += chunk);        ctx.req.on(&quot;end&quot;, () =&gt; resolve(data))        ctx.req.on(&quot;error&quot;, err =&gt; reject(err))        }    )}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一次小程序开发，出现的坑以及一些知识&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL深入浅出索引</title>
    <link href="http://yoursite.com/2019/10/30/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/10/30/MySQL索引/</id>
    <published>2019-10-30T07:25:25.000Z</published>
    <updated>2019-11-11T10:04:01.901Z</updated>
    
    <content type="html"><![CDATA[<p>一句话简单来说，<strong>索引的出现其实就是为了提高数据查询的效率</strong>，就像书的目录一样。</p><p>一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p><a id="more"></a><h2 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h2><p>虽然索引可以提高数据查询的速度，但是任何事物都是双刃剑，它也有一些缺点： 索引占据一定磁盘空间，就 像 有 按 笔画查找的目录的书会比没有这种目录的书页数要多一些。</p><p>索引减慢了数据插入和删除的速度。因为每次插入和删除的时候都需要更新索引，一个 表拥 有的索引越多，则写操作的平均性能下降就越大。 </p><h2 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h2><p>索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p><ul><li>哈希表</li></ul><p>哈希表这种结构<strong>适用于只有等值查询</strong>的场景，比如 Memcached 及其他一些 NoSQL 引擎</p><ul><li>有序数组</li></ul><p>在<strong>等值查询和范围查询</strong>场景中的性能就都非常优秀</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，有序数组索引<strong>只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p><ul><li>二叉搜索树</li></ul><p>特点：每个节点的左儿子小于父节点，父节点又小于右儿子。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，<strong>更新的时间复杂度</strong>也是 O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，<strong>这个 N 差不多是 1200</strong>。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p><p>假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。</p><p>这个表的建表语句是：</p><pre><code>mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>主键与索引的区别：主键也是一种索引，主键也是一种唯一索引，但索引的作用主要是提高查找速度，而主键作用主要是标识记录唯一性（当然也便于查找）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一句话简单来说，&lt;strong&gt;索引的出现其实就是为了提高数据查询的效率&lt;/strong&gt;，就像书的目录一样。&lt;/p&gt;
&lt;p&gt;一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="http://yoursite.com/2019/10/30/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/10/30/面试总结/</id>
    <published>2019-10-30T07:25:25.000Z</published>
    <updated>2019-11-15T08:05:20.955Z</updated>
    
    <content type="html"><![CDATA[<p>关于面试的点点滴滴</p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://yangshun.github.io/tech-interview-handbook/coding-round-overview" target="_blank" rel="noopener">如何准备编程面试</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/cheatsheet" target="_blank" rel="noopener">面试备忘录</a>：涉及面试前需要准备的问题，收到面试题的考虑方式、编程测试准备流程、面试总结</li><li><a href="https://yangshun.github.io/tech-interview-handbook/algorithms/algorithms-introduction" target="_blank" rel="noopener">算法小贴士</a>：各类算法小贴士，以及按主题分类过的最容易考到的问题</li><li><a href="https://github.com/yangshun/front-end-interview-handbook" target="_blank" rel="noopener">前端求职面试问题答案</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/company-interview-formats" target="_blank" rel="noopener">互联网大厂的面试形式解析</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/behavioral-questions" target="_blank" rel="noopener">科技巨头们的通用常见问题，以及几个大厂的常见通用非技术问题</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/questions-to-ask" target="_blank" rel="noopener">适合在面试结束时问考官的好问题！</a></li><li><a href="https://yangshun.github.io/tech-interview-handbook/resume" target="_blank" rel="noopener">做简历注意事项，让你的简历更能引起面试官注意</a></li><li><a href="http://www.cjjjs.com/page/topicinfo?id_topic=63" target="_blank" rel="noopener">面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于面试的点点滴滴&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>腾讯COS项目记录</title>
    <link href="http://yoursite.com/2019/10/30/%E8%85%BE%E8%AE%AFCOS/"/>
    <id>http://yoursite.com/2019/10/30/腾讯COS/</id>
    <published>2019-10-30T07:25:25.000Z</published>
    <updated>2019-11-15T08:05:14.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-master-nodejs"><a href="#https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-master-nodejs" class="headerlink" title="https://github.com/tencentyun/qcloud-cos-sts-sdk/tree/master/nodejs"></a><a href="https://github.com/tencentyun/qcloud-cos-sts-sdk/tree/master/nodejs" target="_blank" rel="noopener">https://github.com/tencentyun/qcloud-cos-sts-sdk/tree/master/nodejs</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-master-nodejs&quot;&gt;&lt;a href=&quot;#https-github-com-tencentyun-qcloud-cos-sts-sdk-tree-mas
      
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="多媒体" scheme="http://yoursite.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>vim常用操作</title>
    <link href="http://yoursite.com/2019/10/30/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/10/30/vim常用操作/</id>
    <published>2019-10-30T01:48:05.000Z</published>
    <updated>2019-11-07T01:06:16.618Z</updated>
    
    <content type="html"><![CDATA[<p>vim  工作常用命令</p><a id="more"></a><p><a href="https://vimsky.com/wp-content/uploads/2015/03/131.jpg" target="_blank" rel="noopener">vim 常用总结图片</a></p><h2 id="工作常用"><a href="#工作常用" class="headerlink" title="工作常用"></a>工作常用</h2><ul><li>查找替换<pre><code>/text　　查找text，n下一个，N前一个?text　　查找text，反向查找，n下一个，N前一个</code></pre></li></ul><p>ra 将当前字符替换为a，当期字符即光标所在字符。<br>:s/old/new/ 用old替换new，替换当前行的第一个匹配<br>:s/old/new/g 用old替换new，替换当前行的所有匹配<br>:%s/old/new/ 用old替换new，替换所有行的第一个匹配<br>:%s/old/new/g 用old替换new，替换整个文件的所有匹配</p><pre><code>- 复制粘贴</code></pre><p>dd    删除光标所在行<br>x    删除当前字符<br>yy    复制一行，此命令前可跟数字，标识复制多行，如6yy，表示从当前行开始复制6行<br>p    粘贴粘贴板的内容到当前行的下面  大P 为上面</p><pre><code>- 移动光标</code></pre><p>h,j,k,l    上，下，左，右<br>gg → 到第一行<br>G → 到最后一行</p><pre><code>## 常见用法</code></pre><p>i → Insert 模式，按 ESC 回到 Normal 模式.<br>x → 删当前光标所在的一个字符。<br>dd → 删除当前行，并把删除的行存到剪贴板里<br>p → 粘贴剪贴板</p><p>normal模式下：<br>插入：a → 在光标后插入  o → 在当前行后插入一个新行  O → 在当前行前插入一个新行  cw → 替换从光标所在位置后到一个单词结尾的字符<br>移动光标：0 → 数字零，到行头    ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）<br>$ → 到本行行尾    g_ → 到本行最后一个不是blank字符的位置。<br>/pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）<br>拷贝/粘贴：P → 粘贴  p是表示在当前位置之后，P表示在当前位置之前<br>w → 到下一个单词的开头。<br>e → 到下一个单词的结尾。</p><p>撤销与重做<br>u           撤销（Undo）<br>U           撤销对整行的操作<br>Ctrl + r    重做（Redo），即撤销的撤销</p><p>ZZ 保存并退出<br>:q! 强制退出并忽略所有更改<br>:e! 放弃所有修改，并打开原来文件</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim  工作常用命令&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="命令" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
  </entry>
  
</feed>
